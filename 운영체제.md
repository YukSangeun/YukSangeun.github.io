**알고리즘, 운영체제, 데이터베이스, 자료구조, 네트워크** (15분 test)

# 운영체제

**운영체제(Operation System)** 목적:

* 사용자에게 **자원 사용의 편리성**을 제공
* 효율적인 자원관리를 통해 **처리 능력 향상, 반환시간 최소화, 신뢰성과 사용가능도를 증대**해 시스템의 성능 극대화
  * 처리능력, 반환시간, 신뢰도, 사용가능도는 운영체제의 성능을 평가하는 기준
    1. 처리능력(Throughout): 일정 시간동안 시스템이 처리해야 하는 양
    2. 반환시간(Turn around Time): 시스템이 작업을 제출한 후 결과가 출력될 때까지의 시간
    3. 신뢰도(Realiablity): 시스템이 오류 없이 주어진 문제를 정확하게 해결하는 정도
    4. 사용가능도(availability): 시스템 사용이 필요할 때 즉시 사용 가능한 정도

운영체제의 기능:

* 사용자와 시스템 간의 **편리한 인터페이스 제공**
* CPU(프로세서), 메모리, 입출력장치 및 파일 등의 **자원 관리**
* **자원 스케쥴링 기능**을 통한 자원 관리
* 하드웨어 및 데이터 등 **자원의 공유 기능**
* 시스템의 **오류 처리**
* **입출력에 대한 보조 기능**
* 컴퓨터 시스템의 **초기화 담당**
* **보안 및 네트워크의 관리 기능 제공**



1. 운영체제는 **커널 모드와 사용자모드**로 나뉘어 구동된다.
   * 커널모드: 운영체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드. CPU 내부 mode bit = 0
   * 사용자모드: 일반 사용자 프로그램이 실행되면 제한적인 명령만을 수행. mode bit = 1
   * **시스템의 중요한 영향을 미치는 연산**을 **커널 모드에서만** 실행 가능하게 함으로써 하드웨어의 보안 유지

2. 동작 방식: **인터럽트 구동식**
   * interrupt: 프로그램 수행 중 CPU가 강제로 제어를 가져오는 것을 의미
     * Interrupt가 발생하면 **interrupt service routine(명령어, ISR)**의 위치가 기록되어 있는 **interrupt vector table**로 이동하여 해당하는 명령어를 찾아 수행
     * 하드웨어 인터럽트: 정전 또는 전원 공급의 이상, 하드웨어 오류, 타이머 인터럽트, 입출력 장치 등
     * 소프트웨어 인터럽트(Trap): 허가되지 않은 메모리 주소 참조, 0으로 나누기, **시스템 콜**, 페이지 부재 등
   * **Interrput Service Routine** : 인터럽트 핸들러라고도 하며 실제 인터럽트를 처리하는 루틴
   * **Interrput Vector Table** : 각 인터럽트가 발생 시 처리해야 할 루틴의 주소를 보관하는 테이블
   * **System Call**: 사용자 프로세스가 소프트웨어 인터럽트를 통해 커널의 기능을 이용하기 위한 서비스를 요청하는 방법. ex. 파일 open. write 등

3. 운영체제의 자원관리
   1. 프로세스 관리: 프로세서(CPU)에서 실행되는 프로그램 관리.
      * 프로세스 상태변이와 스케쥴링
      * 상호배제, 동기화, 교착상태 등 병행 프로세스
   2. 메모리 관리: 메모리 할당 및 회수. 가상메모리 운용
   3. 입출력 관리: 입출력 인터페이스. 제어. 스케쥴링
   4. 파일 관리

# Process Scheduling

**process**

* 현재 cpu에 의해 실행 중인 프로그램 (OS로부터 실행에 필요한 메모리를 할당 받는다.)
* PCB를 가진 실행 가능 프로그램
* 운영체제가 관리하는 실행 단위

1. 프로세스의 상태 전이
   * **new**: 프로세스 생성. 사용자의 작업이 디스크의 할당 위치에 저장된 상태
   * **Ready**: CPU할당 받기 위해 메모리에 준비 중인 상태 (스케쥴링 큐에서 준비). 
   * **Running**: CPU할당을 받아 실행 중인 상태. 인터럽트 발생시 ready큐로 이동된다.
   * **Waiting**: 어떤 이벤트 (I/O or event)가 발생해 running상태에서 대기 큐에 옮겨와 완료될때까지 대기 상태. 완료되면 ready 큐로 이동
   * **Terminated**: 프로세스 실행 완료한 상태. exit
2. 프로세스의 상태 전환
   * **Dispatch(Ready -> Running)** : CPU할당 받음
   * **Interrput(Running -> Ready)** : 인터럽트 발생 or 해당 프로세스에게 CPU할당되는 시간 종료될 경우 다른 프로세스를 위해 준비상태로 전환
   * **Block(Running -> Waiting)** : 입출력 명령을 만나 처리가 완료될때까지 대기 상태
   * **Wake up(Waiting -> Ready)** : 입출력 완료되어 대기에서 준비상태로 전환
3. **Context Switch**
   * 이전 프로세스의 상태 레지스터 정보를 보관하고 다른 프로세스의 레지스터들을 적재하는 과정
   * 빈번한 문맥교환은 시스템의 과부하를 초래
4. 프로세스 제어 블록 (PCB, Process Control Block)
   1. 프로세스 생성 시 고유의 PCB 생성되며, 완료 시 PCB 또한 제거 (프로세스1 -> PCB 1)
   2. 프로세스에 대한 중요 정보를 제공해 주는 저장 장소

**Process Scheduling**

여러 프로세스가 실행될 때 필요로 하는 자원을 어떻게 할당해 줄 것인가를 결정하는 작업

1. 스케줄링의 형태
   1. 장기
      * Job Sheduler에 의해 담당
      * 디스크 공간에 제출된 프로세스를 선택하여 메모리로 적재 (ready 상태로 바꿈)
   2. 중기
      * CPU를 차지하기 위해 경쟁하는 프로세스들의 수를 줄여 CPU의 과부하를 방지
   3. 단기
      * 일반적인 스케줄링 개념, CPU sheduler에서 담당
      * 메모리 안의 ready 상태 프로세스들 중 한 프로세스를 선택하여 CPU 할당 (running 상태로 바꿈)
2. 스케줄링의 목적
   1. 공정성: 모든 프로세스에게 공정하게 자원을 할당
   2. 무한대기 방지: 우선순위 낮은 프로세스도 실행 가능하게
   3. 균형 있는 자원 사용: 시스템의 모든 자원을 가능한 한 균형 있게 사용
3. **비선점 스케줄링 알고리즘**
   1. **FIFO or FCFS** scheduling
      * 공평성은 좋지만 긴 작업이 짧은 작업을 기다리게 할 수 있다.
      * **Convoy effect**: 소요시간이 긴 프로세스가 먼저 도달하여 시간을 잡아먹고 있는 부정적인 현상
      * 일괄처리 작업에 적합. 대화식 시스템에 부적합
   2. **SJF(Shortest Job First)** scheduling
      * 준비 큐 내에서 실행시간이 가장 짧은 프로세스에게 CPU할당
      * 평균 대기시간이 최소인 최적의 알고리즘
      * 실행시간이 긴 작업 경우 **무한연기(starvation)** 발생 가능
   3. **HRN(Hightest Response ration Next)** scheduling
      * 긴 작업과 짧은 작업 간의 지나친 불평등을 어느정도 보완한 기법
      * 우선순위 책정 시, 실행시간과 대기시간을 고려
      * 짧은 작업이나 대기시간이 큰 작업은 우선순위가 높아짐
   4. **Priority** scheduling
      * 프로세스마다 우선순위를 부여하여 우선순위가 높은 순서대로 CPU할당
      * 우선순위 낮은 경우 **Starvation** 발생
      * **Starvation**해결책: **에이징(Aging)기법**: 프로세스의 우선순위가 낮아 자원을 양보하거나 대기시간이 증가할 수록, 프로세스의 우선순위를 한 단계씩 높여주는 기법. 기아현상을 방지
   5. **Deadline** scheduling
      * 특정 기한 내에 완료하도록 스케쥴링
4. **선점 스케룰링 알고리즘**
   1. **RR(Round Robin)** scheduling
      * 시분할 시스템에서 적용하는 방식
      * FIFO알고리즘에 의해 순서대로 할당 받고, CPU의 시간할당량(**time slice**)동안만 실행
      * 시간 할당량이 많아지면 FIFO와 동일. 너무 작으면 context switch의 빈번함으로 오버헤드 크다
   2. **SRT(Short Remaining Time)** scheduling
      * 실행시간 추정치가 가장 작은 프로세스에게 먼저 CPU할당 기법
      * SJF기법에 선점방식을 도입한 기법으로, 프로세스 처리 중 선점 허용
   3. **MLQ(Multi Level Queue)** scheduling
      * 프로세스를 작업 유형에 따라 여러 그룹으로 분류하고 그룹별 준비 큐를 준비하여 프로세스 진입 시 유형에 따라 각 큐에 배당
      * 각 큐는 독자적인 스케쥴링 수행이 가능
      * 특정 큐에 진입한 프로세스는 다른 준비 큐로 이동 불가능
   4. **MFQ(Multi level Feedback Queue)** scheduling
      * 준비큐간 이동이 가능
      * 프로세스 진입시 상위큐로 진입 후 하위큐로 이동한다.

# 프로세스 동기화 (Synchronization)

**race condition**: 동시에 여러 개의 프로세스들끼리 하나의 자원을 두고 경쟁하는 상황. 자료의 일관성을 해치는 결과가 나타날 수 있다.

이를 해결하기 위해 **동기화**가 필요!

**동기화**: 병행프로세스가 공유자원을 사용할 때, 프로세스 간 처리순서를 결정하는 방법

**임계영역**: 둘 이상의 프로세스가 동시에 접근하면 안되는 공유자원 영역

* 상호 배제(mutual exclusion): 특정 프로세스가 임계영역 사용중이면, 다른 프로세스 접근 불가능
* 진행(Process): 임계구역을 사용하고 있지 않다면, 다른 프로세스가 접근할 수 있도록 한다.
* 한계 대기(bounded waiting): 같은 프로세스가 임계구역을 계속 독점 사용하는 것을 막는다. 무한 대기하는 프로세스 막기

**Busy waiting**: 계속적으로 무한 루프를 돌면서 최대한 다른 스레드에게 CPU를 양보하지 않는 것 = spinlock



**프로세스 동기화 방법**

1. mutex : 하나의 프로세스만 자원에 접근하므로 한 프로세스만 실행
2. semaphore : 지정한 수 만큼 프로세스가 동시에 실행
3. monitor: 공유자원을 프로세스들에게 할당하는 데 필요한 데이터와 프로시저의 집합으로 이루어지는 **병행성 고급언어 구조체**

# DeadLock

**교착상태(DeadLock)**

둘 이상의 프로세스가 더 이상 계속할 수 없는 어떤 특정 사건을 기다리고 있는 상태. 즉, 어떠한 프로세스도 실행 안됨

**발생 조건**

1. 상호배제: 한 번에 한 프로세스만이 자원 사용
2. 점유와 대기: 자원을 일부 점유하면서 다른 자원을 기다리는 경우
3. 비선점: 프로세스가 완료되기 전에 자원을 회수할 수 없는 경우
4. 환형(circular) 대기: 자원을 할당 받은 두 프로세스가 서로 할당된 자원을 요청하는 경우

**해결 방안 3가지**

1. 교착상태 **예방**(Prevention) : 교착상태의 발생가능성을 없애는 방법
   * 자원 낭비가 심하고, 기아상태 초래
   * 각 발생조건을 부정
2. **회피**(avoidance) : 시스템 운영 상황을 보면서 교착상태 가능성을 피해가는 방법
   * 자원할당 그래프 or 은행원 알고리즘 이용
   * 자원할당 그래프: 사이클 생길 것 같으면 사용자의 자원 요구 거부
   * 은행원 알고리즘: 안전상태를 유지할 수 있는 요구만을 수락하고, 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있도록 계속 거절 (안전 순서로 자원 할당)
     * 안전상태: 교착상태 안일으키며, 각 프로세스가 요구한 최대 요구량만큼 할당 가능 상태
     * 불안전상태: 교착상태가 일어날 수 있는 상태, 무조건 데드락 발생은 아님
3. 교착상태 **탐지**(detection) 및 **복구**(recovery) : 이미 발생한 교착상태를 탐지알고리즘이나 자원할당 그래프, 대기 그래프의 사이클 유무에 다라 찾아낸 후 복구하는 방법

# OS의 메모리 관리

운영체제는 각 프로세스들을 독립된 메모리 영역에 할당하고, 다른 프로세스가 접근하는 것을 막는다.

프로세스에 메로리 할당방법

1. 연속할당: 연속된 공간에 메모리 할당
   * 메모리는 시스템의 block단위로 할당됨
   * 메모리 낭비가 발생할 수 있음 -> **단편화**
   * **단편화**: 기억장치 공간에서 프로그램이나 작업에 할당할 수 없는 조각난 공간
     * 내부 단편화: 분할된 영역에 프로그램이나 작업이 할당된 후 남는 기억공간
     * 외부 단편화: 분할된 영역이 작아 프로그램이나 작업을 할당 받지 못하는 기억공간
       * 해결법: 압축(할당된 공간들을 한쪽으로 모아 공간 확보), 통합(인접한 단편화 공간 합치기)
2. 비연속할당: 가상메모리를 활용해 할당
   1. 페이징(paging): 프로그램 공간인 logical memory는 page단위의 블록, physical memory는 frame단위 블록으로 분할한 후, page table을 이용해서 페이지의 logical address와 프레임의 physical memory를 사상시켜 관리하는 방법
      1. page table또한, 메모리에 있기 때문에 메모리접근이 2번 발생함. 비효율적 -> 해결: TLB (일종의 캐시 역할 레지스터) (tlb에 없는 경우만 page table에 접근)
   2. segmentation: 고정된 크기가 아닌 가변 크기의 세크먼트 단위로 나누기. 논리적 구조 단위

3. virtual memory (가상 메모리)
   * demand paging 기법으로 구현 : 실제 필요한 page만 물리 메모리로 가져오는 방식
   * page replacement 알고리즘의 종류
     * FIFO: 가장 먼저 들어온 페이지 교체 -> 벨라디 모순 생길 수 있음(프레임이 증가될수록 페이지 부재율이 감소되어야 하는데 오히려 페이지부재율이 증가되는 현상)
     * Optimal 알고리즘: 앞으로 가장 오랫동안 사용되지 않는 페이지 교체 -> 앞으로 어떤 페이지가 사용될 것인지 예측 힘들다.
     * LRU (Least Recently Used) 알고리즘: 현 시점에서 가장 오랫동안 사용되지 않은 페이지 제거 (stack을 이용해 참조 시간을 기록해야 하므로 시간 오버헤드 발생)
     * NUR(Not Used Recently) 알고리즘: LRU의 단점인 시간 오버헤드 적게하는 방법. 2개의 bit이용해 사용되지 않은 페이지 교체
     * SCR(Second Chance Replacement) 알고리즘: FIFO기반. 페이지를 circular queue형태로 나타냄. 1번의 기회를 더 준다.
4. Thrashing : 자주 페이지 부재가 발생해 페이지 교체가 빈번하게 일어나는 현상



# 파일시스템

**파일 디스크립터**

파일을 관리하기 위한 정보(metadata)를 보관하는 파일제어블록(FCB) (inode)

파일마다 독집적으로 가지며 시스템마다 그 내용이 다르다.



**디렉터리**

파일 시스템 내부에 있으며, 디스크에 존재하는 파일에 대한 정보를 가지고 있는 테이블

각 파일의 위치, 크기, 할당 방식, 형태, 소유자 등의 정보를 가진다.



**파일 시스템 마운팅**

사용하고 싶은 파일을 소융한 파일 시스템을 특정한 directory에 마운트하면 그때부터 그 파일을 사용할 수 있다.