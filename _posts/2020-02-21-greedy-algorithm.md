---
title: "Greedy Algorithm(탐욕 알고리즘)"
excerpt: "미래를 생각하지 않고 각 단계에서 최선의 선택을 하는 알고리즘"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Algorithm
tags:
  - greedy
last_modified_at: 2020-02-20T18:19:00
---
답을 찾을 때 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전탐색이나 동적계획법과 동일하다.  

|차이|   |
|----|----|
|완전탐색, 동적계획법|모든 선택지를 고려해 보고 그 중 전체 답이 가장 좋은 것을 찾는다.|
|탐욕 알고리즘|미래를 생각하지 않고 지금 단계에서 가장 좋은 방법만을 선택한다.|

사용 경우  
----------  
탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, DP보다 수행시간이 훨씬 빠르므로 유용한다.  


**주의**  
최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많기 때문에 실수에 유의해야 하며 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋다.  


**참고**  
1. 그리디 알고리즘으로 최적의 해를 구할 수 있는 문제가 많지 않다.
	- global maximum으로 향하는 길에 시작점에 따라 현재 시점이 최고라 여겨지는 곳이 존재하여 local maximum에 빠지는 경우가 있다.  


	![local maximum](https://yuksangeun.github.io/assets/images/greedy_localmaximum.png){: .align-center}  


2. 구할 수 있다면 성질이 동일하게 보존되므로 같은 전략을 반복해서 사용하여 정답을 얻을 수 있다.  

예제1 - 동전 개수  
-----------------------------------------------------  
**문제**- 10원, 50원, 100원, 500원짜리 동전들을 이용하여 어떤 금액을 표현하자. 이때 각 동전은 무수히 많은 대신 동전 개수를 최소로 사용해야 한다.  


**풀이**- 무조건 사용할 수 있는 한 가장 큰 금액의 동전을 많이 사용하면 됨  
ex)620원 : 500 + 100 + 10 + 10 //최소 동전 개수 4개  


**이 방식이 성립하는 이유**-  사용 가능한 동전 500,100,50,10을 보면 큰 쪽이 작은 쪽 액수의 배수가 되기 때문!  
즉 큰 금액의 동전을 자신의 약수인 더 작은 여러 개의 동전들로 교체하면 동전 개수가 반드시 늘어나지만, 작은 동전들을 모아 큰 동전 액수를 만들 수 있다면 동전 개수 줄일 수 있다.  
배수관계가 아닐 경우 – 60, 50, 10  
220원 = 60*3 + 10*4 //총 7개 (위 풀이 방식대로 할 경우)  
220원 = 60*2 + 50*2 // 총 2개  

예제2 - 도시락 문제  
---------------------------------------------------  
**문제**- N개의 도시락이 있고, 전자레인지는 단 한 대만 존재하며 한 번에 하나의 도시락만 데울 수 있고, 각 도시락은 조리시간과 먹는 시간이 다르게 정해져 있다. 이때 도시락을 적절한 순서로 조리하여 첫 번째 도시락을 데우기 시작한 순간부터 모든 도시락을 먹는 데 걸리는 시간이 최소가 되게 해야 한다. (다 데운 도시락은 바로 누군가가 먹는다.)  


**풀이**- 먹는 데 시간이 오래 걸리는 도시락부터 순서대로 데우면 된다!  


**이유**- 도시락을 데우고 나서 바로 다른 도시락을 데우는 걸 반복하고, 각 도시락을 데우는 시간은 정해져 있으므로 우리는 도시락을 데우는 시간을 줄일 수 없다.  
그러나 만약 마지막으로 데운 도시락을 먹는 데 오랜 시간이 걸린다면 전체 시간이 길어질 것이므로 오래 걸리는 것을 먼저 데우고 먼저 먹기 시작하는 것이 좋다.  
도시락1, 데우는 시간 C1, 먹는 시간 E1 / 도시락2, 데우는 시간 C2, 먹는 시간 E2 / E1 >= E2  
* c2->c1 시간: c2 + c1 + max(e1, e2-c1) = c2+c1+e1  
* c1->c2 시간: c1+ c2 + max(e2, e1-c2)  

즉 먹는 시간이 더 긴 도시락을 나중에 데우는 것이 먼저 데우는 것보다 항상 총시간이 길다  

코드(동전개수)  
-------------------- 
 ``` c  
#include<stdio.h>  
using namespace std;
int main() {
     int n, k, coin[10];	//동전 종류, K원
     int cnt = 0;	//필요한 동전 개수
     scanf("%d %d", &n, &k);
     for (int i = 0; i < n; i++)
          scanf("%d", &coin[i]);
     //금액이 큰 동전부터 차례로 보기
     for (int i = n - 1; i >= 0; i--) {
          cnt += k / coin[i];	//필요 개수
          k = k % coin[i];	//이후 남은 금액
     }
     printf("%d", cnt);
}
```  