---
title: "운영체제 : 파일관리"
excerpt: "파일시스템? 파일 및 디렉터리 생성?"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-11
---

## 파일 시스템(File System)

컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체계를 의미한다.

즉, 운영체제가 **저장되어 있는 파일이나 폴더들을 효율적으로 관리 및 읽고 쓰는 행위를 하는 방법**.

사용자의 영역이 아닌 커널 영역에서 동작한다.

disk에 저장되어 있으며 여러 수준으로 구성되어 있다.



**파일 시스템의 기능**

1. 사용자가 파일을 생성, 수정, 제거할 수 있도록 한다.
2. 여러 사용자가 파일을 공유하여 사용할 수 있도록 한다.
3. 불의의 사고에 대비한 백업과 복구 능력이 있다.
4. 주기억장치와 보조기억장치 간의 파일 전송을 담당한다.
5. 각 응용에 적합한 구조로 파일을 구성할 수 있도록 한다.



**파일 시스템의 파일관련 작업**

* 파일 시스템이 파일에 대해 수행하는 작업은 **파일 단위 작업**과 **레코드 작업**으로 구분할 수 있다.
* **파일 단위 작업**
  * open
  * close
  * copy: 새로운 파일 생성
  * destroy: 파일명을 디스크에서 작제
  * rename
  * list: 디스크에 저장되어 있는 파일 목록 출력
* **레코드 단위 작업**
  * read
  * write
  * update
  * insert
  * delete
  * search



**파일 디스크립터(file descriptor)**

* 파일을 관리하기 위한 정보를 보관하는 **파일제어블록(FCB, File Control Block)**이다.
* 보조기억장치에 존재하다가 **파일이 오픈되면** 주기억장치로 이동한다.
* 파일시스템이 관리하며 사용자가 직접 참조할 수 없다.
* 파일 디스크립터는 **파일마다 독립적**으로 가지며 시스템마다 그 내용이 다르다.
* 구성요소
  * 파일명, 파일유형, 접근제어정보, 생성날짜와 시간, 사용횟수, 파일구조 등



**디렉터리(Directory)**

* 파일 시스템 내부에 있으며, 디스크에 존재하는 파일에 대한 정보를 가지고 있는 테이블
* 각 파일의 위치, 크기, 할당 방식, 형태, 소유자 등의 정보를 가진다.
* 디렉터리 종류
  * 1단계(단일) 디렉터리: 모든 파일이 같은 디렉터리 관리되는 가장 간단한 구조로 모든 파일이 유일한 이름을 가져야 한다. 다수의 사용자가 사용하거나 파일의 수가 증가할 때 관리가 어렵다.
  * 2단계 디렉터리: 중앙에 마스터 파일 디렉터리(MFD, Master File Directory)가 있고, 그 아래에 각 사용자에게 할당하는 디렉터리(UFD, User File Driectory)가 있는 주고 / 각 사용자에게 서로 다른 디렉터리를 할당한다.
    * 사용자는 각자 디렉터리를 소유하므로 다른 사용자와 같은 이름의 파일 소지 가능
    * 사용자 이름과 파일이름으로 특정 파일을 명시해야 해서, 파일 이름이 길다.
    * UFD가 독립적이므로 파일을 공유할 수 없다.
  * 트리 구조 디렉터리: 하나의 루트 디렉터리와 다수의 서부 디렉터리로 구성되며, 서로 다른 디렉터리 내에서는 동일한 이름의 파일이나 디렉터리가 생성가능
    * 파일 및 디렉터리 탐색은 **절대 경로**와 **상대 경로**를 이용한다.
    * 디렉터리 생성 및 삭제가 용이
    * Dos, Windows, Unix 운영체제에서 사용하는 구조
    * **절대 경로**: root를 기준으로 해당 파일이나 종속 디렉터리에 이르는 경로
    * **상대 경로**: 현재 디렉토리를 기준으로 해당 파일이나 디렉터리까지의 경로
  * 비순환(비주기) 그래프 디렉터리(Acyclic Graph Directory): 하위 파일이나 디렉터리의 **공유를 허용**하지만, **사이클이 없는** 그래프 구조
    * 하나의 파일이나 디렉터리가 여러개의 경로 이름을 가질 수 있다.
    * 단순 트리 구조보다 융통성이 좋지만 복잡하다.
    * 공유된 하나의 파일을 탐색할 경우 다른 경로로 두 번 이상 찾아갈 수 있어서 시스템 성능 저하
    * 공유된 파일을 삭제할 경우, 파일은 삭제되었지만 파일을 가리키는 포인터는 남아있는 고아 포인터(dagling pointer)가 발생할 수 있다.
  * 일반 그래프 디렉토리: 트리구조에 링크를 첨가하여 **사이클이 허용**되는 구조, 파일이나 디렉터리의 **공유 가능**
    * 그래프 탐색알고리즘이 간단해 파일이나 디렉터리 접근 용이
    * 불필요한 파일 제거를 위해 참고 계수기(counter) 필요
    * 제거된 팡리의 디스크 공간 확보를 위해 쓰레기 수집 필요



**파일 시스템 마운팅(mounting)**

* 파일에 접근하려면, 파일 시스템이 프로세스들에 의해 미리 장착(mount)되어야 한다.
* 사용하고 싶은 파일을 소유한 파일시스템을 특정 directory에 mount하면 그 때부터 해당 파일을 사용할 수 있다. 이 때 특정한 directory를 mount point라고 한다. (일반적으로 mount point는 비어있는 디렉터리)



**파일 sharing**

multi-user system은 파일을 공유한다.



**파일보호**

* 비밀번호, 파일 접근 제어 등을 통해 보호한다.

* 파일 접근 제어: 각 파일마다 접근 목록을 두어 접근 가능한 사용자와 가능한 동작을 기록해 이를 근거로 접근을 허용하는 기법
  * owner, group, public으로 나뉘며, 각각 read, write, execute 권한설정이 가능하다.
* 파일 접근 유형: read, write, execute, append, delete, list



## 파일 접근 방법

OS가 하나의 파일이 필요하다면, open()함수를 통해 파일을 준비시켜야 한다.

**open()과정**

1. open("파일이름")함수 호출 > 시스템 콜
2. system-wide-open-file table을 통해, 이미 다른 프로세스가 파일을 열었는지 확인
3. 만일 디렉토리 내에 존재한다면, 해당 프로세스의 per-process-open-file table에 system-wide-open-file table의 해당 파일 entry를 포인터로 가리키고, system-wide-open-file table의 값을 1증가
4. 만일 존재하지 않다면, 
   1. 메모리에 있는 directory structure cache를 업데이트
   2. 해당 파일의 FCB값을 system wide open file table의 entry에 copy한다.
   3. 그 다음 per-process-open-file-table이 해당 entry를 가리키게 한다.



**System wide open file table**: 열려 있는 file의 FCB를 복사하여 가지고 있는 table로 시스템에 한개 존재

**Per process open file table**: system wide open file table의 주소와 함께 file의 offset과 권한 등을 나타내는 table로 프로세스마다 따로 존재



## 파일 할당 방법

하나의 디스크에 여러 파일이 저장되는데, 디스크에서 파일들을 배치하는 방법은 여러 개가 있다. 

1. 연속할당: 파일들을 디스크 내의 연속적으로 인접된 공간(리스트처럼)에 할당하는 방법
   * 한 파일의 연속 할당은 **디스크 주소(블록단위)와 길이**로 정의된다.
   * 파일의 길이 n블록이고 블록 b에서 시작한다면,  b, b+1, b+2, ..., b+n을 차지한다.
   * 장점:
     * 논리적으로 연속된 레코드들이 물리적으로 서로 인접하게 저장되므로 엑세스 시간이 감소
     * 디렉터리는 파일 시작주소와 길이 정보만 있으면 되므로 단순하고 구현이 용이
   * 단점:
     * 새로 생성되는 파일의 기억공간의 크기를 미리 결정하며 외부단편화가 발생
     * 파일 크기에 맞는 기억공간이 확보되지 않으면 그 파일을 생성되지 못함
     * 공간 확보를 위해 재배치를 이용한 주기적인 압축이 필요
2. 연결할당(Linked Allocation): 파일을 디스크 블록의 연결 리스트모양으로 할당하는 방법
   1. 파일의 디스크 블록들이 디스크 내에 흩어져 있다.
   2. 디렉토리는 파일의 **첫번째와 마지막 블록에 대한 포인터**를 가진다.
   3. 장점:
      * 외부 단편화가 없다.
      * 모든 블록들은 크기가 같기 때문에 자유 공간 리스트의 어떠한 자유 블록을 이용해도 된다.
      * 파일의 크기가 미리 고정될 필요가 없으며, 파일은 계속해서 커질 수 있다.
      * 주기적으로 밀집화 할 필요가 없다.
   4. 단점:
      * 순차적 접근 파일에만 효과적이다. (직접 접근에는 비효율적)
      * 포인터를 관리하기 위한 추가 공간이 필요
      * 포인터를 잃어버리거나 잘못된 포인터 주소를 가질 경우 모든 자료를 잃는다.
   5. 개선법: **파일 할당 테이블(FAT, File Allocation Table)** 사용
   6. **FAT**: 파일이나 디렉토리의 위치정보(포인터)를 저장하는 테이블
      * 디스크 헤더가 FAT정보를 읽어 임의의 블록 위치를 알아낼 수 있어, Direct access도 가능
      * Pointer를 별도의 공간에 저장해 reliability(신뢰성) 문제 해결
      * FAT 테이블은 각 디스크 블록마다 한 개의 항목을 가지고 있고, 이 항목은 디스크 블록 번호를 색인으로 찾는다.
3. 색인 할당(Indexed Allocation): 각 파일의 디스크 블록 주소를 모아 놓은 하나의 색인 블록을 두고, 이를 통해 직접 접근이 가능하게 한 방법
   * 색인 블록의 i번째 항목은 파일의 i번째 블록을 가리킨다.
   * 디렉토리는 **색인 블록의 주소**를 가지고 있다.
   * 장점:
     * 외부 단편화가 없다.
     * direct access가 가능
     * sequential access 가능
   * 단점:
     * 연결 할당의 포인터 오버헤드보다 더 포인터 오버헤드가 크다 (공간낭비)
     * 작은 파일일지라도 하나의 색인 블록이 할당되므로



## 디스크 자유 공간 관리 (free-space management)

디스크의 공간은 제한되어 있어서, 새로운 파일들을 위해 빈 공간(자유공간)을 관리해야 한다.

**관리법**

1. 비트 벡터(bit vector): 자유공간을 리스트로 구현하고, 리스트를 비트 맵 또는 비트 벡터로 구현. 각 블록은 1비트로 표현된다. (비트가 1이면 자유블록, 0이면 할당 블록)
   * 첫번째 자유블록 혹은 n개의 연속된 자유블록을 찾는 데에 간편한 방법
2. 연결리스트(linked list): 모든 자유 블록을 연결시키는 방법