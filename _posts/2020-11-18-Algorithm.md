---
title: "알고리즘 : 면접 질문 정리"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-18
---



## 알고리즘

**정렬 알고리즘**

버블소트: n개의 원소를 가진 배열을 정렬할 때, 

힙소트

머지소트

삽입정렬

선택정렬

퀵소트

**divide and conquer**



**DP**

동적 계획법이란 복잡한 문제를 간단한 여러 개의 하위 문제로 나누어 푸는 방법을 말합니다. 두 가지 방식으로 구현이 되며 top down 방식과 bottom-up 방식이 존재합니다.

top down방식 경우 큰 문제를 여러개의 하위 문제를 나누고 하위 문제들을 결합하여 최종적으로 최적의 해를 구합니다. 같은 하위 문제를 가지는 경우가 존재하며 중복 계산을 방지하기 위해 계산 값을 메모리에 저장해 사용하는 memoization기법을 사용합니다. 이를 통해 문제 계산 속도를 향상합니다. 재귀를 이용하여 구현합니다.

bottom up 방식 경우 작은 문제부터 계산해 나가는 방식으로 for문을 사용해 상위 문제를 해결해나갑니다.

**Greedy**

그리디 알고리즘은 탐욕적 알고리즘으로 각 단계별 지금 당장 좋은 방법만을 선택하여 해결하는 방식입니다. 동적 계획법보다 수행시간이 훨씬 빠르기 때문에 우용하지만 많은 경우 최적해를 찾지 못하며 적용 가능 경우가 두가지로 제한됩니다.

* 탐욕법을 사용해도 항상 최적해를 구할 수 있는 경우
* 시간이나 공간적 제약을 최적해 대신 근사해를 찾아서 해결하는 경우

**재귀 알고리즘과 재귀의 시간 복잡도**

재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다신 호출하여 문제를 해결하는 알고리즘 입니다. 재귀 알고리즘은 계속해서 자신을 호출함으로써 끝없이 반복하게 되므로 반복을 중단할 조건이 반드시 필요합니다.

팩토리얼을 계산하는 재귀함수에서는 T(n) = T(n-1) + c (n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 아래와 같이 O(n)이 됨을 알 수 있습니다.

```
T(n) = T(n-1) + c
	= T(n-2) + 2c
	= T(n-3) + 3c
	= ...
	= T(1) + (n-1)c
	<= c + (n-1)c = cn = O(n)
```



**n개의 배열에서 k번째로 큰 수 찾는 알고리즘**

보통 퀵정렬 알고리즘을 사용하여 해결할 수 있습니다. 하지만 퀵정렬을 사용할 경우 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 됩니다. 때문에 부분만 정렬을 수행할 수 있도록 퀴선택 알고리즘을 사용합니다.

* 퀵선택 알고리즘이란 퀵정렬 후 피봇의 인덱스와 k를 비교해 아래와 같이 수행합니다.
* pivot의 인덱스 == k인 경우: 인덱스의 값 리턴
* pivot의 인덱스 < k인 경우: pivot의 인덱스 +1 부터 배열의 끝 인덱스까지 다시 partition함수에 넘겨준다.
* pivot의 인덱스 > k인 경우: pivot의 인덱스 -1 부터 배열의 처음 인덱스까지 partition함수에 넘겨준다.
* 시간 복잡도는 n + n/2 + n/4 + ... + 1 = O(n)

**허프만 코딩이란**

허프만 코딩은 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여합니다. 허프만 코드는 접두부 코드와 최적 코드를 사용합니다.



