---
title: "백준 1039번 교환"
excerpt: "BFS 알고리즘을 사용한 문제"


categories:
  - Problem
tags:
  - BFS
  - graph
last_modified_at: 2020-02-16
---
**문제**  
-----------  
0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.
> 1<= i < j <= M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 
> 이때, 바꾼 수가 0으로 시작하면 안된다.  
위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.  

**입력**
-----------
첫째 줄에 정수 N과 K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, K는 10보다 작거나 같은 자연수이다.  
> 참조: https://www.acmicpc.net/problem/1039  

**풀이**
-----------
탐색 시 깊이가 K번째인 경우까지만 탐색하므로 BFS 알고리즘을 사용한다.  
초기 i번 째 깊이에서 교환하여 얻을 수 있는 값들을 모두 queue에 넣는 방식으로 탐색을 수행했지만(visited[]사용 없이) **메모리 초과**가 발생했다.  
즉, **방문 여부를 확인하여** 방문된 곳은 queue에 넣지 않는 방식을 사용하여 문제를 풀어야 한다.  
같은 깊이의 값들을 탐색 후 k를 감소시키는 방식을 사용하였으며 k==0인 경우 탐색을 종료하고 탐색시 찾은 최고 높은 값을 반환한다. 

 
깊이별 포함된 값들을 생각해보자.  (깊이 i)  
i가 홀수인 경우 값 num을 i번 교환하여 얻을 수 있는 값들의 집합은  (i번째에서 교환하여 찾은 값들 + 깊이i 이전 홀수번째 깊이들에서 가능했던 값들)이다.  
마찬가지로 i가 짝수인 경우 값 num을 i번 교환하여 얻을 수 있는 값들의 집합은 (i번째 교환하여 찾은 값들 + 깊이i 이전 짝수번째 깊이들에서 가능했던 값들)이다.  
즉, 홀수끼리 집합이 형성되고 짝수끼리 집합이 형성된다.  
따라서 우리는 최댓값을 찾을 때, **홀수깊이에서의 최댓값과 짝수깊이에서의 최댓값을 따로 구해야한다.**


위에서 언급한 것과 같이 탐색할 때 k를 감소시키는 방향으로 했다. (k가 짝수인 경우, 홀수인 경우를 생각해보자  
k=3인 경우  
--> k=3일 때 같은 깊이 값들 탐색, k=2일 때 같은 깊이 값들 탐색, k=1일 때 같은 깊이 값들 탐색, k=0일 때 탐색 종료 후 반환  
k=2인 경우  
--> k=2일 때 같은 깊이 탐색, k=1일 때 같은 깊이 탐색, k=0일 때 탐색 종료 후 반환  
k가 짝수, 홀수인 경우 두 경우를 모두 볼 때 최종적으로 k=1일 때까지만 탐색을하게 된다.  
즉, 위에서 최댓값을 찾을 때 홀수깊이, 짝수깊이에서의 각각 최댓값을 찾으면 된다했지만 실제로 우리가 사용하는 것은 k의 값이 홀수인 깊이들이다.  
따라서 우리는 k의 값이 홀수인 깊이들에 대해서만 값들을 비교하여 최댓값을 찾으면 된다.

* 소스코드

		  #include<stdio.h>
		  #include<queue>
		  using namespace std;
		  
		  bool visited[1000001];	//방문 여부
		  int m = -1, k;	//입력받은 값의 자리수, 교환 횟수
		  char arr[7];	//값 num에 대한 교환을 쉽게 하기 위해 각 자리 수마다 배열에 넣기
		  int num;
		  
		  queue<int> qu;
		  int bfs() {
		       int maxxO = -1;	//k가 홀수 일 때 최댓값
		       while (!qu.empty()) {	//이때 qu에는 깊이가 같은 값들만 들어있다.
		            int size = qu.size();
		            while (size--) {	//깊이가 같은 값들에 대해서 탐색 수행
		                 num = qu.front();
		                 qu.pop();
		                 for (int i = 0; i <= m; i++) {
		                      arr[i] = '0' + num % 10;
		                      num = num / 10;
		                 }
		                 //swap
		                 for (int i = m; i >= 0; i--) {
		                      for (int j = i - 1; j >= 0; j--) {
		                           if (arr[j] == '0' && i == m) continue;
		                           char tem = arr[j];	// i, j번째 자리 교환
		                           arr[j] = arr[i];
		                           arr[i] = tem;
		                           num = 0;
		                           for (int l = m; l >= 0; l--)
		                                num = num * 10 + (arr[l] - '0');
		                           arr[i] = arr[j];	//교환된 값은 num에 저장했으므로 원래 자리로 원위치하여 다음 교환을 가능하게 한다.
		                           arr[j] = tem;
		                           if (k % 2 == 1 && maxxO < num)	//k가 홀수일 때 값을 비교한다.
		                                maxxO = num;
		                           if (visited[num]) continue;
		                           visited[num] = true;
		                           qu.push(num);
	                                     }
		                 }
		            }
		            k--;	//같은 깊이 수행 후 k감소
		            if (k == 0) break;	//k번 수행 완료한 경우 탐색 중단
		       }
		       return maxxO;	//가장 큰 값을 반환한다.
		  }
		  
		  int main() {
		       scanf("%d %d", &num, &k);
		       qu.push(num);	//bfs()시작시 사용할 값을 미리 qu에 넣는다.
		       while (num > 0) {	//자리수 세기 ex)1234일 경우, m=3 (0번부터 센다)
		            m++;
		            num = num / 10;
		       }
		       printf("%d", bfs());
		  }
