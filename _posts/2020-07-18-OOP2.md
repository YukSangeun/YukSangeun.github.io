---
title: "객체지향 프로그래밍: 특성"
excerpt: "캡슐화(은닉화), 추상화, 상속성, 다형성"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-07-18
---
OOP의 특성: 캡슐화(은닉화), 추상화, 상속성, 다형성  


## 캡슐화(encapsulation)와 은닉화(hiding)  
목적: **코드를 재수정 없이 재활용하는 것**  
* 캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활하다.  
* 기능과 특성의 모음을 **클래스**라는 **캡슐**에 분류해서 넣는 것  


**캡슐화**  
* 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 접근이 가능하게 하는 작업  
* 변수와 함수를 하나의 단위로 묶음  
* 외부의 잘못된 사용으로 객체가 손상되지 않기 위해 접근제한자(public, protected, private)를 사용해서 설정  
* 장점  
	1. 변경이 발생할 때 객체의 포함된 정보의 손상과 오용을 막음  
	2. 데이터가 바뀌여도 다른 객체에 영향을 주지 않아 독립성 유지  


**정보 은닉(information hiding)**  
캡슐화의 한 개념으로, 프로그램의 세부 구현이 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것이다.  
class에서의 public, private, protected와 같은 접근 제한이 이의 예이다.  
- public: 클래스의 외부에서 사용 가능하도록 노출시키는 것  
- protected: 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것  
- private: 클래스의 내부에서만 사용되며 외부로 노출되지 않는 것  


## 추상화(abstraction)  
객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정  
즉, **중요한 건 남기고 불필요한 것과 자세한 것은 생략**하는 것이다.  


**장점**  - 복잡도 관리  

추상(抽象) : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.  


ex. 사람 객체경우  
추상화 - 눈, 코, 이름, 성별, 키, 잔다, 뛴다 등  
추상화 불가 - 날다  


## 상속성(inheritance)  
하나의 클래스(객체)가 다른 클래스(객체)의 특성을 이어받을 수 있게 해주는 과정  
자식 클래스는 부모 클래스의 모든 특성을 상속받고, 자기 자신의 특성을 추가 시켜 정의할 수 있다.  
* 다른 사람이 만든 소스 코드를 내 의도에 맞게 수정하게 되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 불필요한 코드의 수정작업을 해야한다.  
* 이런 문제를 해결하기 위해 **[상속]**이라는 것이 도입됨  


**장점**  
1. 코드 중복 작업 최소화로 개발 시간 절약  
2. 소프트웨어의 재사용성 증대  
3. 유지 보수 시간 최소화  


**Overriding(오버라이딩)**  
자식 클래스에서 상속받은 기능을 수정하여 재정의 하는 작업  


**클래스 상속의 형식**  
``` c++  
class derived_class_name : access base_class_name{

}
/*
access 속성에 따른 차이점
1. public
	1) 기본 클래스의 public멤버는 파생 클래스의 public  
	2) 기본 클래스의 protected멤버는 파생 클래스의 protected  
	3) 기본 클래스의 private 멤버는 상속이 안됨(접근 불가)  
2. protected  
	1) 기본 클래스의 public과 protected는 파생 클래스이 protected  
	2) 기본 클래스의 private 멤버는 상속이 안됨(접근 불가)  
3. private  
	1) 기본 클래스의 public과 protected 멤버는 파생 클래스의 private  
	2) 기본 클래스의 private멤버는 상속이 안됨(접근 불가)  
*/
```  


## 다형성(polymorphism)  
하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다.  
즉, **오버라이딩(overriding)과 오버로딩(overloading)**이 가능함을 의미  
* 오버라이딩: 부모 클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것  
* 오버로딩: 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것  
![오버로딩과 오버라이딩](https://yuksangeun.github.io/assets/images/subject/oop3.PNG){: .align-center}  


**장점**  
객체의 부분화 가능  


**다형성 종류**  
1. 서브타입 다형성: 상위 클래스의 포인터나 참조 변수 등이 하위 클래스의 객체를 참조하게 하는 것.  
2. 매개변수 다형성: 타입을 매개변수로 받아 새로운 타입을 되돌려주는 기능  
	템플릿, 제네릭이 이것의 예이다.  
3. 임시 다형성  
	1) 함수 오버로딩: 같은 이름의 함수가 매개변수에 따라 다른 기능으로 동작하도록 하는 것.    
	2) 연산자 오버로딩: 기본 연산자가 해당 객체에 맞는 역할을 수행 가능하도록 하는 것.   
4. 강제 다형성  
	1) 묵시적 형 변환: 암묵적으로 표시하지 않아도 int에서 double과 같은 식으로 알아서 자료형이 변하는 것(자료형 승급).  
	2) 명시적 형 변환: double에서 int처럼 묵시적으로 형 변환하지 않는 경우 명시적으로 표현하여 형 변환시키는 것.  


## getter, setter를 사용하는 이유?  
멤버변수에 직접 접근하지 못하게 private으로 접근지정자를 설정하고 public으로 getter와 setter 메서드를 만드는 것을 많이 해왔다.  
getter와 setter로 private에 지정한 변수에 접근 가능한데 왜 멤버변수를 private으로 설정할까?  


getter와 setter를 사용하면 **메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문**이다.  


예를 들면, setter에서 유효범위를 넘은 정수가 들어왔을 때 처리를 하고나서 set하거나 예외처리를 해버릴 수 있다.  
마찬가지로 getter에서도 자료에 무언가 더하거나 빼고 준다든지가 가능하다.  
