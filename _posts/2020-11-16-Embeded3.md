---
title: "임베디드 시스템 : RTOS 스케쥴링"
excerpt: "인터럽트? RMS? EDF? 실시간 스케쥴링의 문제점과 해결책?"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-16
---

## 인터럽트

비동기적 이벤트가 발생함을 CPU에서 알려주는 하드웨어 매커니즘이다.

ISR로 문맥전환 후, 가장 높은 우선순위를 갖는 태스크가 다음 수행되도록 조정한다.



**인터럽트 지연 시간 (interrupt latency)**

인터럽트에 반응해 ISR을 수행하기(전)까지의 시간 = 인터럽트가 꺼져있는 최대 시간 + 인터럽트 서비스 루틴을 수행하는 데 필요한 시간

**인터럽트 응답 시간 (interrupt response)**

인터럽트에 반응해 서비스 루틴을 수행하기까지의 시간 = 지연시간 + CPU 문맥 저장시간 + 커널의 ISR진입함수 수행하는데 걸리는 시간

**인터럽트 복구 시간 (interrupt recovery)**

CPU 내용 되돌리는 시간 + 가장 높은 우선순위 태스크 선택 시간 + 가장 높은 우선 순위의 태스크로 돌아가는 시간



## 스케쥴러

RTOS에서 각 task는 데드라인이 정해지며 그 기한내에 종료할 필요가 있다. **적시성 보장이 중요!**



**Real-Time Scheduling**

* Rate-Monotonic Scheduling (RMS)
* Earliest Deadline First scheduling (EDF)



**RSM**

* 기본적으로 **static priority** 스케쥴링 알고리즘이다.
* 데드라인(주기)이 짧은 task일수록 더 빨리 수행해야 하므로 우선순위가 높다. (데드라인 짧은 = 높은 우선순위)
* 주기적으로 발생하는 task일 경우 주기 == 데드라인
* schedulibility test? 모든 테스크가 그들의 기한안에 모두 수행완료한다면 task set은 실현가능하다. (반대도 가능)
  * Utilization = (주어진 task의 utilization의 합) = (모든 task의 Ci(worst-case computation time)/Ti(period) 의 합) <= n(2^(1/n) - 1)  이라면 해당 task set은 feasible!
  * 위조건을 만족한다면 무조건 실현 가능
  * 조건 불만족해도 U가 1보다 작다면 무조건 불가능이라 할 수 없다. (필요충분은 아님, 1보다 작으면 가능할 수도 있다)

**EDF**

* 기본적으로 **dynamic priority** 스케쥴링 알고리즘이다.
  * 현 시간에 데드라인에 가장 근접한 task순으로 우선순위가 바뀐다.
  * task가 완료되는 시점마다 우선순우가 재 계산된다.
* schedulibility test
  * 필요충분 조건: Utilization <= 1



## 실시간 스케줄링의 문제점과 해결책

**우선순위 전도현상**

* 가정: 고정 우선 순위 선점형 스케쥴링
* 정의: 높은 우선순위의 태스크가 낮은 우선순위 태스크에 의해 블럭킹되는 현상
* 언제 발생? **공유된 자원**을 사용하면서 생기는 문제
* 문제점:
  1. 낮은 우선순위 task가 공유자원 접근
  2. 높은 우선순위 task가 공유자원 접근하고자 함. lock걸려 대기
  3. 중간 우선순위 task가 낮은 우선순위 task를 선점
  4. **우선순위 전도현상이 발생** (무기한 blocking)
* 해결책: 임시로 낮은 우선순위 task가 높은 우선순위 task의 우선순위를 상속받는다. (블럭킹 시) => **우선순위 계승 프로토콜**
  * 이럴 경우, 중간 우선순위가 선점할 수 없고 낮은 우선순위가 수행 완료 후 높은 우선순위가 ready상태가 되어 선점 가능하다.



**우선순위 계승 프로토콜**

* 아이디어: 어떤 태스크가 높은 우선 순위를 갖는 태스크를 블럭시켰을 경우
  * 그 태스크는 그 태스크에 의해 블록된 태스크 중 가장 높은 우선순위를 가진 태스크의 우선순위를 상속받는다.
  * **이행적 성질**
  * 임계 영역을 벗어났을 때 우선순위를 되돌려 놓는다.
* 특징: indefinite blocking 해결
* mc/os-II에서 구현: mutex semaphore
  * OSMutexCreate(현재 사용하지 않는 가장 높은 우선순위(PIP),  &err) : 만약 task1이 task3에 의해 block된다면, task3의 우선순위를 OSMutexCreate에 지정한 우선순위로 높여준다.

* 문제: 
  * 이행 블록킹 (transitive blocking, 직접적 관련 없는 task를 기다리기 위해 걸리는 시간)
  * 데드락 (한정된 자원을 여러 테스크가 접근하길 원할 때 발생)
* 해결책: **우선순위 상한 프로토콜**



**우선순위 상한 프로토콜**

* 아이디어: 
  * 자원의 우선 순위 상한 값 (자원에 우선순위가 생긴 것)
    * 해당 자원을 쓰려는 태스크 중 가장 높은 우선 순위를 갖는 태스크의 우선 순위
  * 어떤 특정 Job J가 임계영역에 들어가기 위한 조건
    * J의 우선순위가 현재 J가 아닌 다른 태스크에 의해서 락이 걸려 있는 모든 자원의 우선순위 상한 값 중 최대값 보다 커야 한다.
    * 이용가능하다고 무조건 사용할 수 있는것이 아닌다. 우선순위 낮은 job이 선점하지 못하게 하기 위해 더 높은 우선순위 먼저 수행한다.
  * 순서:
    1. 먼저 모든 자원에 대해 우선순위 상한값을 계산한다.
    2. 실제 스케쥴링 진행되면서, 현재 자신을 제외한 다른 태스크에 의해 락이 걸려있는 자원이 있는지, 있다면 상한 값의 최대값을 확인하고 나의 우선순위와 비교한다.
    3. 내가 더 크면 진입가능하고, 아니면 block처리된다.
* 특징
  * 이행 블록킹 문제 해결
  * 데드락 해결