---
title: "운영체제 : 디스크(Second storage structure)"
excerpt: "디스크?"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-11
---

**Disk**: 컴퓨터의 보조 기억 장치, 비휘발성 ex) 하드디스크, 플로피 디스크 등



## 디스크의 구조(Disk structure)

**logical block**

디스크의 외부에서 보는 디스크의 단위 정보 저장 공간

주소를 가진 1차원 배열로 인식하며, **정보를 전송하는 최소 단위**

logical block은 물리적인 디스크에 매핑된 위치



**sector**

디스크 내부에서 **디스크를 관리하는 최소 단위**

sector0은 최외각 실린더의 첫 트랙에 있는 첫번째 섹터



## 디스크 관련 시간

1. 탐색시간(seek time): 헤드를 해당 데이터가 존재하는 트랙이나 실리더 위에 위치시키는데 소요시간 (disk arm의 head)
2. 회전 지연시간(latency time): 디스크 원판이 회전하여 섹터가 헤드의 바로 아래에 위치할 때까지 소요시간
3. 전송시간(transfer time): 디스크와 주기억장치 간 실제 데이터가 이동하는데 소요시간
4. 접근시간(access time): 탐색시간 + 회전지연시간 + 전송시간 -> 탐색 시간이 제일 크다.



## 디스크 스케쥴링(disk scheduling)

주기억장치에 부재중이지만, 사용해야 할 데이터가 디스크상의 여러 곳에 저장되어 있을 때 데이터를 접근하기 위해 **디스크 헤드를 움직이는 경로를 결정하는**기법

* os가 담당한다.
* **스케쥴링 탐색시간(seek time)을 최소하 하는 것**이 목표이다.



**스케쥴링 종류**

1. FCFS(First Come First Served): 디스크 입출력 요구들을 도착한 순서대로 서비스하는 기법

   * 순서가 바뀌지 않으므로 공평성이 보장
   * 디스크의 부화가 커지면 응답시간이 길어진다.
   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   가장 먼저 입력된 요구인 160을 시작으로 순서대로 수행
   
   이 경우 헤드의 총 이동 거리는
   60+40+10+80+150+170+70+10 = 690
   ```

2. SSTF(Shortest Seek Time First): 현재 헤드의 위치로부터 가장 가까운 거리에 있는 요청을 서비스

   * FCFS보다 처리량이 많고 평균 응답시간이 좋다.
   * 가장 안쪽이나 바깥쪽의 트랙은 기아 현상이 일어나, 응답시간의 편차가 크다.
   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   헤드와 가장 가까운 90을 먼저 처리. 이후, 90에서 가장 가까운 120을 처리
   따라서, 처리 순서는
   90 -> 120 -> 130 -> 160 -> 170 -> 190 -> 200 -> 20 
   
   헤드의 총 이동 거리는
   10 + 30 + 10 + 30 + 10 + 20 + 10 + 180 = 300
   ```

   

3. SCAN: 헤드 진행 방향과 같은 방향의 가장 짧은 거리에 있는 요청을 먼저 서비스

   * 헤드 이동 중 서비스 요청이 없어도 헤드는 진행 방향의 **끝까지 이동한 후 **반대쪽 방향 전환
   * **엘리베이터 방식**으로 운행, 대부분의 디스크 스케쥴링의 기본 전략
   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   헤드와 가장 가까운 90을 먼저 처리한다.
   90은 100보다 안쪽에 위치하므로, 헤드는 안쪽으로 움직이며 요구를 처리한다.
   따라서, 90을 처리한 후 20을 처리하며, 헤드가 끝에 다다르면(0) 반대로 진행한다.
   
   헤드의 총 이동 거리는
   10 + 70 + 20 + 120 + 10 + 30 + 10 + 20 + 10 = 300
   ```

4. LOOK: SCAN의 문제점을 개선한 스케쥴링 방식으로 **실제 서비스 요청이 있는 트렉까지만** 이동한 후 방향 전환을 하며, 헤드 이동거리 단축

   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   SCAN과 처리 순서는 같으나 20보다 더 작은 트랙이 없으므로 20까지만 이동후 방향 전환을 한다.
   
   요구가 처리되는 순서는
   90 -> 20 -> 120 -> 130 -> 160 -> 170 -> 190 -> 200
   
   총 이동 거리는
   10 +70 + 100 + 10 + 30 + 10 + 20 + 10 = 260
   ```

5. C-SCAN(Circular-SCAN): 헤드가 항상 **바깥쪽 트랙에서 안쪽**으로 진행하면서 가까운 요청을 서비스

   * 서비스 요청이 없어도, 맨 안쪽 트랙까지 이동한 후 다시 맨 바깥쪽으로 헤드가 이동하여 안쪽으로 진행
   * 안쪽이나 바깥쪽 트랙에 대한 기아현상을 제거
   * 응답시간의 편차가 매우 적다.
   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   안쪽으로 진행하며 요구들을 처리하다 디스크의 끝에 도달했을 때,
   255 헤더로 요구에 대한 처리없이 이동하여 다시 안쪽으로 진행하며 요구들을 처리한다.
   
   처리 순서,
   90 -> 20 -> 0 -> 255 -> 200 -> 190 -> 170 -> 160 -> 130 -> 120
   
   이동 거리는
   10 + 70 + 20 + 255 + 55 + 10 + 20 + 10 + 30 + 10 = 490
   ```

   * C-LOOK: C-SKAN의 방식의 문제점을 개선한 스케쥴링, 실제 서비스 요청이 있는 트렉까지만 이동한 후 맨 바깥쪽의 트랙으로 이동

6. N-Step SCAN: 헤드가 한쪽 방향으로 이동해 나가면서 **최소 요청에 의해서 들어온 것**만 서비스 하다가 다시 반대쪽으로 오면서 이전에 도착했던 요청들을 서비스

   * SSTF나 SCAN방법보다는 응닶시간의 편차가 적다.
   * 요청이 많아도 대기 중인 요청만 처리하므로 기아현상이 발생하지 않는다.
   * 예

   ```
   226개의 트랙, 현재 헤드의 위치가 100이고, 입출력 대기큐가 다음과 같다.
   [160, 200, 90, 170, 20, 190, 120, 130]
   
   80요구
   
   헤드와 가장 가까운 90을 먼저 처리한다. 80의 요구가 들어왔다면
   이 80이 비록 90보다 안쪽에 위치하더라도, 이 요구는 처리되지 않는다.
   80이라는 요청은 헤드가 끝(0)에 다다른 후, 진행방향이 바뀌었을 때 비로소 처리된다.
   따라서, 요구가 처리되는 순서는,
   90 -> 20 -> 0 -> 80 -> 120 -> 130 -> 160 -> 170 -> 190 -> 200
   
   총 이동 거리는
   10 + 70 + 20 + 80 + 40 + 10 + 30 + 10 + 20 + 10 = 300
   ```

   

## 디스크 관리(disk management)

**초기화(formatting)**: 사용환경에 맞게 구조/형식을 정하는 일

1. low-level(=physical) formatting: 디스크가 처음에 하는 포맷과정, 디스크에 물리적 구조를 만들어 낸다.
   * 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터( sector)들로 나누는 과정
   * 보통 공장 출하 전에 시행되어 진다.
   * sector는 header information, data, ECC를 담고 있으며 주로 512byte
2. logical formatting: partitioning후 , 각 파티션마다 파일시스템을 구축. os가 디스크 공간의 파일을 접근 가능하도록 한다.
3. partitioning? 디스크를 논리적으로 분할하는 것으로 보통 하나의 디스크를 1개 이상의 파티션으로 구성한다.