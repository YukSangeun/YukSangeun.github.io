---
title: "임베디드 시스템 : 운영체제와 Task"
excerpt: "운영체제? ms/os-II?"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-16
---

## 운영체제

**태스크**

* 수행중인 프로그램
* 스케쥴링 단위



**멀티 태스킹**

* 여러 개의 태스크를 동시에 실행시키는 것
* 일반 OS에서의 태스크: 각 태스크들은 대부분 무관한 프로그램임
* 임베디드 시스템에서의 태스크:
  * 하나의 큰 응용 프로그램을 논리적으로 나눈 것 - 기능상 매우 밀접한 관계를 가지고 태스크 사이에 이루어지는 작업들이 많다.
  * 응용 프로그램 실행을 위해 여러 기능들이 동시 실행 요구 - 순차적이 아닌 동시 실행의 필요성이 있다.



**스케쥴러**

* OS의 핵심 기능으로 다음번에 어떤 태스크를 실행해야 하는 지를 결정하는 코드 부분이다.
* 다른 태스크로 실행이 넘어갈 때 문맥전환이 발생한다.
* **context switching?** 현재 수행 중인 태스크 상황 하에서의 시스템 상태(문맥)을 TCB라는 특정한 자료구조에 저장하고, 다음에 새로운 태스크의 문맥을 가져와 시스템 상태를 복원한 후에 실행하는 것
* context switching은 overhead가 크기 때문에 짧을 수록 효율적이며 thread의 개념을 통해 보완할 수 있다.



**프로세스 vs 쓰레드**

* 용어
  * 프로세스: 운영체제로부터 시스템 자원을 할당받는 작업의 단위로 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
  * 쓰레드: 프로새스내에서 실행되는 여러 흐름의 단위로 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
* 특징
  * 프로세스: 운영체제로부터 각각 독립된 메모리 영역(Stack, data, heap, code)을 할당받으며, 기본적으로 하나의 프로세스에 메인 쓰레드가 같이 생성된다. 각 프로세스는 다르 프로세스의 자원에 접근하기 위해 IPC를 사용해야 한다.
  * 쓰레드: 프로세스 내에서 동작하는 여러 실행의 흐름으로 프로세스 내에서 각가 Stack만 따로 할당 받고 Code, Data, Heap 영역은 공유한다. 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 쓰레드끼리 공유하며 실행한다.

**multiProcess vs multiThread**

* multiProcess
  * 멀티 프로세싱: 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
  * 장점: 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스들에게 영향을 미치지 않는다.
  * 단점: context switching의 오버헤드, 프로세스 사이의 어렵고 복잡한 통신기법(IPC)
    * 오버헤드: 문맥교환 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모 되는 등의 오버헤드가 발생한다. 프로세스가 각각의 독립된 메모리 여역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어 문맥교환 시 캐쉬에 있는 모든 데이터를 리셋하고 다시 캐쉬 정보를 불러와야 한다.
    * IPC: 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.
* multiThread
  * 멀티 쓰레딩: 하나의 응용 프로그램을 여러 개의 쓰레드로 구성하고 각 쓰레드로 하여금 하나의 작업을 처리하도록 하는 것이다. 윈도우, 리눅스 등 많은 os들은 멀티 프로세싱을 지원하고 있지만 멀티 쓰레딩을 기본으로 한다.
  * 장점:
    * 시스템 자원 소모 감소 (자원의 효율성 증대): 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    * 시스템 처리량 증가(처리 비용 감소): 프로세스 간의 통신보다 쓰레드 간 통신이 비용이 적으므로(stack을 제외한 모든 메모리를 공유하기 때문) 통신 비용이 줄어들게 된다. 쓰레드 사이의 작업량이 작아 문맥교환이 빠르다.
  * 단점:
    * 주의 깊은 설계가 필요하다. (미묘한 시간, 잘못된 변수 공유로 오류 발생 확륭 증가)
    * 디버깅이 까다롭다.
    * 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
    * 멀티 쓰레드의 경우 자원 공유의 문제가 발생. (동기화 문제)
    * 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
* 멀티쓰레드 사용이유?
  * 자원의 효율성 증대: 메모리 공유로 시스템 자원 소모 줄어듬, 자원할당 시스템 콜 줄어들어 효율적 관리 가능
  * 처리 비용 감소 및 응답 시간 단축: IPC보다 쓰레드 간의 통신의 비용이 적으므로 작업들 간 통신의 부담 줄어듬, 문맥전환 속도가 빠르다(stack영역만 처리하기 때문)
* 주의할점!!
  * 동기화 문제
  * 쓰레드 간의 자원 공유는 전역 변수를 이용하므로 함께 사용할 때 충돌이 발생할 수 있다.



**테스크간 통신**

* task communication
  * 전역변수 쓰는 방법 (세마포 사용, mutex) / message passing 방법 (mailbox, queue, pipe)
* task synchronization
  * 세마포 / 이벤트 플래그 / 시그널 등
  * 이벤트 플래그? 일종의 자료구조로서, 각 비트는 특정한 사건(event)에 대응되며 이벤트가 발생하면 각 비트를 1 또는 0으로 설정한다. 여러 이벤트에 대한 동기화가 가능하다. (메세지 전달은 불가능하며, 이벤트 발생여부 검사할 수 있다)



**재진입 코드 (Reentrancy code)**

인터럽트, 선점의 개념과 연관있으며, 하나의 함수를 여러 태스크가 동시에 수행 가능하다.

재진입 코드란 동시에 언제 접근해도 언제나 같은 실행 결과를 보장하는 코드를 의미한다. 즉, 태스크1이 함수1을 실행하다가 태스크2로 제어가 넘어가고 태스크2가 함수1을 호출해도 함수1은 태스크1과 태스크2에서 모두 제대로 동작하는 코드를 의미한다.

재진입 코드에서는 전역변수를 사용하지 않는다 - 공유 자원이기때문에 상호배제하도록 만들어 주지 못하는 문제가 존재한다.

재진입 하지 못하는 코드는 공유하지 않거나 공유해야 하는 경우 세마포를 쓰거나 동일 우선순위를 갖는 태스크 사이에 round-robin을 하지 않아야 한다.

```c++
//재진입 가능 함수
void swap(int *x, int *y){
	int temp;
	temp = *x;
	*x = *y;
	*y = temp;
}

//재진입 불가능 함수
int temp;
void swap(int *x, int *y){
	temp = *x;
	*x = *y;	//여기서 문맥교환 발생후 다른 태스크가 swap함수 재호출하면 temp값이 바뀌게 된다. 
				//즉, 이전에 이함수를 호출했던 태스크의 작업이 제대로 동작하지 않게된다.
	*y = temp;
}
```



## ms/OS-II

학교나 개인의 교육과 같은 비상업적 목적에 한해 자유로이 사용 가능한 공개 소스 - 소스코드의 수정 및 컬널의 내부 구조를 이해하기 용이하다.

실시간 운영체제이다.

**특징**

1. source code - 깔끔하고 매우 작다. (20Kb의 공간만 있어도 실행 가능)
2. portable - 커널 코드의 대부분이 이식 가능한 ANSI C를 기반 / 8bit, 16bit, 32bit, 64bit, DSP로도 porting 가능
3. reliable - safety-critical system에도 사용할 수 있는 안전한 운영체제
4. ROMable - 해당 C컴파일러, 어셈블러, 링커, 로더가 있으면 내장이 용이
5. **선점형 실시간 코드 - 높은 우선 순위 작업이 먼저 수행** (static priority scheduling, osTaskChangePrio()함수를 호출해 바꾸지 않는한 우선순위는 고정된다. os가 자체적으로 바꿔주지 않는다. )
6. multitasking - 최대 64개의 태스크 지원, 일부 task(63, 62번 task)는 OS에서 사용하도록 정해져 있음 (실시간성을 위헤 제약이 좀 많다.)
	* 63번 task: idle task  
	* 62번 task: statistics task (cpu 사용률 계산)

**일반 운영체제와 큰 차이점**

리눅스 경우 user모드와 kernel모드가 구분되어 있고 task들은 user모드에서 동작하는  한편, mc/OS-II는 user와 kernel 구분이 되어 있지 않으며 모든 task들이 kernel에서 동작한다. 이에 task한개가 메모리 잘 못 접근 시 kernel에 영향끼치게 된다.



**Task State**

* DORMANT: 이미 task가 64개 존재하기 때문에 new라는 표현 쓰지 않는다. OSTaskCreate() or OSTaskCreateExt()함수 호출 시 해당 task가 READY로 변경된다.
* READY: 스케쥴 후보
* RUNNING: CPU할당 받고 task 동작
* Delayed: 일정시간동안 task가 멈춘 상태로 만료시 READY로 바뀐다.
* WAIT: 몇몇 이벤트가 발생하기 위해 task가 waiting된다. 스케쥴될 수 없다.
* ISR: intterupt service routine이 실행된다.



**READY list**

64개의 task들은 dormant 상태면 0, ready이후면 1로 구분되며 각 task의 TCB free list들은 연결 리스트로 따로 관리된다. 실행된 task들의 TCB는 double linked list로 관리된다.

상수시간 O(1)에 한 태스크가 ready list에 존재하는 지를 확인하기 위해 bitmap을 이용한다. (heap, list를 이용하는 방법에 비해 시간을 빠르나 더 많은 공간을 소비한다)

가장 높은 우선순위의 task를 찾을 때 사용한다. - 스케쥴링시



**Task 스케쥴링**

1. Task 수준의 스케쥴링 - OS_Sched()함수에 의해 수행
2. ISR수준의 스케쥴링 - OSIntExit()함수에 의해 수행 > 현재 수행중인 task정보를 TCB에 저장하는 것까지는 task수준과 동일
   * 차이점: 인터럽트 수행 후 새로운 task 로딩할 때 이전 task정보를 저장할 필요가 없다.  (ISR에서 task 수행하므로) 단순 로딩만 하면 된다.
