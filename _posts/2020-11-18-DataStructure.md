---
title: "자료구조 : 면접 질문 정리"
excerpt: ""

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-18
---



## 자료구조

**자료구조와 알고리즘**

자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조입니다. 

알고리즘이란 자료구조에 쌓이 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임입니다.

**array 와 linked list를 설명해주세요**

array란 논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조입니다. 따라서 인덱스로 해당 원소에 접근이 가능해 찾고자 하는 원소의 인덱스 값을 알고 있다면 상수시간에 해당 원소에 접근이 가능한, random access라는 장점이 존재합니다. 하지만, 배열에 값이 연속적으로 저장된다는 특징으로 인해 값을 중간에 삽입과 삭제시 번거로움이 존재하며 최악의 경우 O(n) 시간이 소요되는 단점이 있습니다.

linked list란 선형으로 연결된 노드들을 가지는 자료구조입니다. array와 달리 노드간 pointer를 이용해 list를 구현하므로 값을 메모리에 연속적으로 저장하지 않아도 되어 삽입과 삭제시 O(1)시간에 수행이 가능합니다. 하지만 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문에 데이터 접근 시 head부터 순차탐색해야하므로 최악의 경우 O(n) 시간이 소요되는 단점이 존재합니다.

**tree - Binary tree, Full binary tree, complete binary tree, BST(Binary search tree)**

트리는 스택이나 큐와 같은 선형구조가 아닌 비선형 자료구조입니다. 트리는 계층적 관계를 표현하는 자료구조로 노드간 부모-자식 관계가 존재합니다.

트리에서는 각 층별로 숫자를 매겨 이를 트리의 level이라고 표현합니다. 레벨의 값은 0부터 시작하며 루트노의 레벨이 이에 해당합니다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 높이라고 합니다.

* Binary tree: 이진트리란 루트 노드를 중심으로 두 개의 서브 트리로 나누어 지며, 서브 트리 또한 모두 이진트리를 만족하는 구조입니다. 
  * full binary tree: 정 이진트리란 모든 노드가 0 또는 2개의 자식을 가진 트리를 의미합니다.
  * perfect binary tree: 포화이진트리란 모든 레벨이 꽉찬 이진 트리를 의미합니다. 즉, 모든 internal 노드가 2개의 자식을 가지며 leaf 노드들의 깊이가 모두 같은 트리 입니다.
  * complete binary tree: 완전이진트리란 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진트릴를 의미합니다.
* BST (Binary serach tree): 이진 탐색 트리는 이진트리의 일종으로 데이터를 저장하는 규칙이 존재하며 해당 규칙을 통해 특정 데이터의 위치를 찾는데 사용할 수 있습니다.
  * 규칙으로는 이진 탐색 트리의 노드에 저장된 키는 유일하다는 점. 부모의 키가 왼쪽 자식노드의 키보다 크고 오른쪽 자식 노드이 키보다는 작다는 점. 왼쪽과 오른쪽 서브트리 또한 이진탐색 트리라는 점입니다.
  * 이진 탐색 트리의 탐색 연산은 O(h)의 시간복잡도를 가진다. 최선의 경우 O(log n)의 시간복잡도를 가지며, 최악의 경우 값의 저장 준서에 따라 한쪽 방향으로만 노드가 추가되는 경우가 발생해 O(n)의 시간복잡도를 가지게 됩니다. 편향트리를 해결하기 위해 rebalancing 기법을 사용하여 구조의 재조정을 통해 트리 균형을 잡아줍니다. 
  * rebalancing기법을 사용한 tree 중 red-balck tree가 존재합니다. 

**binary heap**

자료구조의 일종으로 tree의 형식을 하고 있으며, tree중에서도 배열에 기반한 complete binary tree입니다. 힙에는 maxheap과 minheap 두 종류가 존재합니다.

maxheap이란 각 노의 값이 children으 값보다 크거나 같은 완전인진 트리이며 min heap은 이와 반대를 의미합니다.

maxheap에서는 root 노드에 있는 값이 가장 큰 값이므로 최대값을 찾는데 O(1)의 시간이 소요되며, minheap경우 root노드에 가장 작은 값이 들어가 최소값을 찾는대 O(1)의 시간이 소요됩니다.

각 heap의 루트노드를 제거한 이후에도 heap구조를 계속 유지하기 위해 제거된 루트노드를 다른 노드로 대체해야 하며, 대체 시 heap의 맨 마지막 노드로 대체 후 heapify과정을 거쳐 heap구조를 유지합니다. 결국 O(log n)의 시간복잡도로 최대값 또는 최솟값에 접근할 수 있습니다.

**red-black tree**

red balck tree(RBT)는 BST를 기반으로하는 rebalancing기법을 이용한 트리 형식의 자료구조입니다. 해당 트리에서 탐색, 삽입, 삭제 연산 수행시 O(log n) 시간이 소요됩니다. 

red black tree는 다음 4가지 조건을 만족해야 합니다.

* 루트 노드의 색은 검정
* external 노드들의 색은 검정
* 빨강 노드의 자식은 검정
* 모든 리프노드에서의 black depth는 동일

삽입: BST의 특성을 유지하며 노드를 삽입하며, 이때 삽입된 노드의 색깔은 RED입니다. (black-height의 변경을 최소화하기 위해) 삽입결과 RBT의 특성을 위해하는 경우 노드의 색상을 조정하고, black-height가 위배되었다면 rotation을 통해 height를 조절합니다. 

삭제: BST의 특성을 유지하며 해당 노드를 삭제합니다. 삭제될 노드의 child의 개수에 따라 rotation방법이 달라지게 됩니다. 그리고 만약 지워진 노드의 색깔이 black이면 black depth가 1 감소한 경로에 balck노드가 1개 추가되도록 rotation하고 노드의 색깔을 조정합니다. 지워진 노드의 색이 red라면 위반이 발생하지 않으므로 rbt가 그대로 유지됩니다.

**graph**

graph란 정점과 정점을 연결하는 간선으로 이루어지며 트리와 달리 계층이 존재하지 않는 자료구조입니다. 

간선의 방향 유무에 따라 directed graph와 undirected graph로 나눠지며, 간선에 가중치가 있을 경우 가중치 그래프라고 합니다. 

degree: 무방향 그래프에서 각 정점에 연결된 edge의 개수를 degree라고 합니다. 방향 그래프 경우 간선에 방향이 존재하기 때문에 degree가 두개로 나뉘게 되며 각 정점으로부터 나가는 간선의 개수를 outdegree, 들어오는 간선의 개수를 indegree라고 합니다.

그래프 구현 방법으로는 인접행령 방식과 인접리스트 방식이 존재합니다.

* 인접행렬: 정방 행렬을 사용하는 방법으로 해당하는 위치의 value값을 통해 vertex간의 연결 관계를 O(1)으로 파악할 수 있습니다. edge의 개수와 무관하게 O(V*V)의 공간복잡도를 가지며, dense graph를 표현할 때 적절합니다.
* 인접리스트: 연결 리스트를 사용한 방법으로 각 노드는 직접 연결된 노들과의 관계를 저장합니다. 이에 간접 연결된 노드들 사이의 연결을 확인하기 위해 오랜 시간이 걸립니다. O(V+E)의 공간복잡도를 가지며 sparse graph를 표현하는데 적절한 방법입니다.

**그래프의 탐색**

* bfs: 너비 우선 탐색으로 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점을 level별로 탐색해 나아갑니다. 자료구조로는 queue를 사용하고 최단 경로를 찾을 때 주로 사용합니다.
  * 시간복잡도: O(V+E) 모든 정점과 노드를 탐색해야 하므로
* dfs: 깊이 우선 탐색으로 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 우선적으로 탐색하는 방법입니다. 연결 가능한 정점이 있을 때까지 계속 깊이 탐색을 수행하며 더이상 연결된 노드가 없으면 이전 단계의 정점으로 돌아가 또다른 연결가능한 정점을 찾아 깊이탐색을 수행합니다. 자료구조로 stack을 사용할 수 있고, 재귀함수를 이용해 구현가능합니다. 
  * 시간 복잡도: O(V+E) 

**Minimum Spanning Tree**

최소 스패닝 트리란 그래프 G의 spanning tree중 edge weight의 합이 최소인 spanning tree를 의미합니다. 여기서 spanning tree란 그래프 G의 모든 노드가 cycle이 없이 연결된 형태를 말합니다.

최소 스패닝 트리를 구하는 방법으로는 kruskal algorithm과 prime algorithm이 존재합니다.

* kruskal algorithm은 초기 간선 없이 정점들로만 이루어진 그래프가 존재할 때, 가중치가 가장 작은 간선부터 그래프에 추가하는 탐욕기법을 사용합니다. 간선을 그래프에 추가하기 위해 사이클 발생여부를 체그하며 사이클이 발생하지 않는 경우 그래프에 추가합니다.
  * 사이클 발생여부를 확인하기 위해 union-find 알고리즘을 사용합니다. 
  * 시간 복잡도: O(E log E)
* prim algorithm: 정점을 중심으로 구현된 알고리즘으로 초기 한 개의 vertex로 이루어진 초기 그래프 G를 구성합니다. 이후 그래프에 존재하는 정점들로부터 외부에 있는 정점들 사이에 간선의 가중치들을 비교해 가장 작은 가중치를 가진 간선으로 연결된 정점을 그래프 G에 추가합니다. 이 과정을 모든 정점들이 G에 포함될때까지 반복합니다.
  * 시간 복잡도: O(E lov V)

**스택, 큐, 트리, 힙 구조 설명**

스택: 선형 자료구조의 일종으로 가장 처음에 넣은 자료가 마지막으로 나오게 되는 First-in Last-out 원칙을 가진 자료구조입니다.

큐: 선형 자료구조의 일종으로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-in First-out 구조를 가진 자료구조입니다.

트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 graph의 특수한 형태로, 계층이 있는 데이터를 저장하기에 적합합니다. 계층이 있기 때문에 각 노드간 부모, 자식 관계가 존재합니다.

힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드는 (key, element)쌍으로 구성됩니다. 각 노드의 키값이 자식의 키값보다 작지 않거나(최대합) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리입니다.

**우선순위 큐와 내부 구조 및 시간복잡도**

우선순위 큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 우선순위에 의해 데이터가 정려되기 때문에 queue에 삽입되는 요소의 순서가 중요하지 않으며 데이터 속성에 따라 제거가 가능합니다.

우선순위 큐를 구현하기 위해서는 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해 구현되기 때문에 우선순위 큐의 시간복잡도는 O(n log n)입니다.

우선순위 큐에 삽입시 정렬되는 구조 경우 각 요소가 해당 자리를 찾아가는데 O(log n)시간이 걸리며 이를 n개의 원소에 대해 진행해야 하므로 O(n log n)시간이 소요됩니다.

**해시 테이블과 해시 테이블의 시간 복잡도**

해시테이블은 (key, value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다. 해시 테이블은 key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.

해시 테이블은 고유햔 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다. 하지만 해시의 index값이 충돌이 발생할 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(n)까지 증가할 수 있습니다.

* 해쉬함수: key값에 해시함수를 적용해 작은 범위의 값들로 바꿔주는 알고리즘입니다. 하지만 해쉬함수를 통해 동일한 값이 출력될 수 있으며 동일한 index를 가진 여러 데이터가 존재할 수 있고 이를 충돌이라 합니다. (서로 다른 두개의 키가 같은 인덱스로 hashing되면 같은 곳에 저장할 수 없게 된다.) 이를 위해 해쉬함수는 충돌을 최소화 하는 방향으로 설계해야 하며 충돌에 대비해 어떻게 대응할 것인지 생각해야 한다. 
* 해쉬 충돌 해결 방법
  * open addressing (개방 주소법): 해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식입니다. 최악의 경우 비어있는 버킷을 찾지 못해 탐색시작한 자리로 되돌아 올 수 있습니다.
    * linear probing: 순차탐색
    * quadratic probing: 2차함수를 이용해 탐색 위치 찾기
    * double hashing probing: 하나의 해쉬함수에 충돌 발생하면 2차 해쉬함수를 이용해 새로운 주소 할당. 위 두가지에 비해 많은 연산량이 요구됩니다.
  * separate chaining (분리 연결법): 추가적인 메모리를 사용해 동일한 버킷에 값이 있으면 링크드 리스트 or 트리로 해당 value를 뒤에 저장하는 방식입니다. 자바 8이상에서는 데이터의 사이즈가 커지면 list대신에 tree의 값을 사용합니다. 데이터의 개수가 일정이상 많아지면 리스트보다 트리를 사용하는게 성능상 이점이 있습니다.
  * 두가지 방식 모두 최악의 경우 O(M)의 시간복잡도를 가지며, 이때 M은 해쉬 버킷의 사이즈를 의미합니다. 하지만 open address방식은 연속된 공간에 데이터를 저장하기 때문에 separate chaining에 비해서 캐시 효율이 높습니다. 때문에 데이터의 개수가 충분히 적다면 open address방식의 성능이 더 좋습니다. (M이 커지게 되면 캐시 적중률이 낮아지기 때문) 또다른 차이점으로는 open address방식경우 버킷을 계속해서 사용하기 때문에 separate chaining을 사용하면 테이블의 확장을 보다 늦출 수 있습니다.
* 보조 해시 함수: 목적은 key의 해시 값을 변형해서 해시 충돌 가능성을 줄이는 것입니다. separate chaining방식을 사용할 때 함께 사용되며 보조 해시 함수로 worst case에 가까워지는 경우를 줄일 수 있습니다.
* 해시 버킷 동적 확장 (resize): 해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 성능 상 손실이 발생할 수 있습니다. 그러므로 hashmap은 키-값 쌍 데이터 개수가 일정 개수 이상이 되면 버킷의 개수를 두 배로 늘립니다. 이럴 경우 충돌로인한 성능 손실 문제를 어느정도 해결할 수 있습니다.

**list, set, map의 차이**

list: 데이터를 순사적으로 저장하며 데이터의 중복을 허용합니다. 또한 데이터로 null값이 가능합니다.

set: 순서없이 key로만 데이터를 저장하며, key의 중복이 불가능합니다. 또한 key로 null값을 허용하지 않습니다.

map: 순서없이 key, value로 데이터를 저장하며, value의 중복을 허용하지만 key의 중복을 허용하지 않습니다. key로 null을 허용하지 않습니다.

**큐와 스택의 구현**

큐: array로 구현하면 pop후 객체를 앞당기는 작업이 필요하다. 하지만 list로 구현하면 객체1개만 제거하면 되므로 삽입 삭제가 용이한 linked list로 구현하는 것이 좋다.

스택: list로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, array로 구현하는 것이 좋다.

알고리즘 문제:

* stack을 사용하여 미로찾기 구현
* queue를 사용하여 heap자료구조 구현
* stack 두개로 queue 자료구조 구현
* stack으로 괄호 유효성 체크 코드 구현



**sorting algorithm에서 stable하다는 것은 무엇을 의미하나요?**

stable하다는 것은 동일한 element가 있을 때 정렬 전의 순서와 정렬 후의 순서가 동일함을 보장하는 것입니다. 

**sorting algorithm이 가짓수가 많은데 그 이유가 무엇일 것 같나요?**

정렬 알고리즘의 가짓수가 많은 이유는 먼저, 정렬 알고리즘마다 예상되는 속도가 다르기 때문입니다. 두번째로 속도가 아닌 공간 복잡도 또한 고려대상이 될 수 있습니다. merge sort 경우 insertion sort나 seleciton sort에 비해 추가 메모리 공간을 사용합니다.

마지막으로 stable한지 안한지에 따라 사용되어야 할 정렬 알고리즘이 다를 수 있습니다.

**quick sort에 대해 설명해 줄 수 있나요?**

quick sort는 divide-and-conquer 전략을 이용해 정렬을 수행하는 정렬 알고리즘입니다. 그중에서도 partitioninig이라는 아이디어를 이용합니다.

partitioning이란 pivot element를 기준으로 왼쪽은 pivot보다 작거나 같은 것을 모아주고 오른쪽은 pivot보다 크거나 같은 것을 모아주는 것을 의미합니다.

이러한 partitioning을 재귀적으로 진행하다보면 정렬이 완료됩니다.

