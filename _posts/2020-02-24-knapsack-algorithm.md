---
title: "Knapsack Algorithm(배낭 알고리즘)"
excerpt: "가능한 무게의 최댓값과 물품당 무게와 가치가 정해져있을 때, 가치의 합이 최대가 되도록 물품을 선택하는 문제"

categories:
  - Algorithm
tags:
  - DP
last_modified_at: 2020-02-24T23:36:00
---
(공부한 내용을 정리한 글로 부족하거나 틀린 부분이 존재할 수 있습니다.)  
**배낭 문제**란 배낭에 물건을 담을 수 있는 무게의 최댓값이 존재하고 물건당 무게와 가치가 정해져 있을 때,  
**가치의 합이 최대**가 되도록 물건들을 선택하여 배낭에 담는 문제이다.  


배낭문제는 크게 두가지 유형이 존재한다.  
1. 물건을 나눠서 넣을 수 있는 경우 (fraction knapsack)  
2. 물건을 나눠서 넣을 수 없는 경우 (0/1 knapsack)  

여기서는 2번을 다룰 것이면 1번에 경우 다른 블로그들을 찾아보니 그리디를 사용하여 간단하게 가능하다고 한다.  

-------------------  
물건을 나눠서 넣을 수 없는 경우에는 (0/1 knapsack) DP를 사용하여 해결할 수 있다.  


0/1 Knapsack  (백준 12865번 평범한 배낭)
---------------  
위에서 말한 것처럼 DP를 이용하여 문제를 해결할 수 있다.  
물건을 나눌 수 없기 때문에 물건을 담거나 / 담지 않거나 이므로 0/1 Knapsack이라 한다.  


백준의 12865번 문제를 예시로 들어 설명할 것이며, 점화식을 먼저 보자.  
```
dp[a][b] : 1부터 a번째 물건까지 사용하여 b 용량의 가방에 물건을 채울 때 최대 가치  
V[a] : a번째 물건의 가치  
W[a] : a번째 물건의 무게  

dp[a][b] = max( dp[a-1][b] , dp[a-1][b-w[a]] + v[a] )
1. b용량의 가방에 a번째 물건을 담지 않을 경우: dp[a-1][b]
	- b용량 가방은 a-1까지 물건으로 채워진 최댓값  
2. b용량의 가방에 a번째 물건을 담을 경우: dp[a-1][b-w[a]] + v[a]
	- 가방에 w[a]만큼 넣으면 남은 가방의 용량은 b-w[a]이다.  
	- (a물건의 가치) + (a-1까지 물건을 사용하여 b-w[a]용량의 가방 채웠을 때 최대 가치)
```  
위와 같은 방식으로 알고리즘이 수행된다.  
이해를 좀 더 쉽게 하기 위해 표를 그려보자.  

-------------------------------------  

> 배낭의 최대 용량 K: 7, 물건 개수 n: 4  
> W[4] : 6, 4, 3, 5   
> V[4] : 13, 8, 6, 12  

1. dp의 0번째 행을 모두 0으로 채워 둔다.  

	|물건＼용량| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  
	|:-----------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
	|0|0|0|0|0|0|0|0|0|  

2. 1번째 물건 (무게: 6, 가치: 13)  

	|물건＼용량| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  
	|:-----------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
	|0|0|0|0|0|0|0|0|0|  
	|1|0|0|0|0|0|0|<span style="color:red">13</span>|<span style="color:red">13</span>|  

3. 2번째 물건 (무게: 4, 가치: 8)  

	|물건＼용량| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  
	|:-----------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
	|0|0|0|0|0|0|0|0|0|  
	|1|0|0|0|0|0|0|13|13|  
	|2|0|0|0|0|<span style="color:red">8</span>|<span style="color:red">8</span>|13|13|  

4. 3번째 물건 (무게: 3, 가치: 6)  

	|물건＼용량| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  
	|:-----------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
	|0|0|0|0|0|0|0|0|0|  
	|1|0|0|0|0|0|0|13|13|  
	|2|0|0|0|0|8|8|13|13| 
	|3|0|0|0|<span style="color:red">6</span>|8|8|13|<span style="color:red">14</span>|  

5. 4번째 물건 (무게: 5, 가치: 12)  

	|물건＼용량| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  
	|:-----------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
	|0|0|0|0|0|0|0|0|0|  
	|1|0|0|0|0|0|0|13|13|  
	|2|0|0|0|0|8|8|13|13| 
	|3|0|0|0|6|8|8|13|14|  
	|4|0|0|0|6|8|<span style="color:red">12</span>|13|14|  

6. 마지막 물건까지 수행 후 dp[4][7]에 들어 있는 값이 최종 답이 된다.  

코드  
--------  

``` c
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;

int dp[100001];	// [용량] = 최대 가치

int main() {
	int n, k;	//물건 개수, 최대 용량
	vector<pair<int, int>> arr;	//물건 정보 {무게,가치}
	scanf("%d %d", &n, &k);
	for (int i = 0; i < n; i++) {
		int w, v;
		scanf("%d %d", &w, &v);
		if (w <= k) {	//무게가 k 초과인 물건은 필요없으므로
			arr.push_back({ w,v });
		}
	}
	//dp - 용량을 뒤에서 부터 볼 경우 1차원 배열로 가능하다. (앞에서 부터 볼 경우 앞에 값들은 계산하며 사용될 수 있어서 2차원 배열 사용해야 함)
	for (int i = 1; i<=arr.size(); i++) {
		for (int j = k; j >=arr[i-1].first; j--) {
			dp[j] = max(dp[j], dp[j - arr[i-1].first] + arr[i-1].second);
		}
	}
	printf("%d", dp[k]);
}
```