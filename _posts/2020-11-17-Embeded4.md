---
title: "임베디드 시스템 : 면접 내용 정리"
excerpt: "전반적인 용어 정리"

toc: true
toc_sticky: true
toc_label: "LIST"

categories:
  - Subject
tags:
  - Programming
last_modified_at: 2020-11-17
---



**실시간 시스템?**

정해진 시간 내에 시스템이 결과를 출력하는 시스템으로 적시성을 가지면 외부 자극에도 예측 가능한 방식으로 반응하는 시스템입니다.

(작업의 요청에서 수행결과를 얻기까지의 시간적인 제약이 존재하는 시스템으로) 시간적인 제약의 엄격함에 따라 경성 실시간 시스템과 연성 실시간 시스템으로 나뉩니다

**적시성?**

디바이스 기기가 열악한 환경에서도 데드라인 이내에 논리적으로도 정확한 출력값을 산출해 내는 것을 의미합니다.

시간 제약을 위해 고속의 프로세싱이 요구되지만 이것만으로 RTOS의 요구되는 예측가능성(허용할 수 있는 시간 내에 결과를 출력할 수 있는지 유무)을 보장하지는 않습니다.

**경성 실시간 시스템 (hard real-time system)?**

작업의 실행 시작이나 완료에 대한 시간 제약 조건을 지키지 못하는 경우 시스템에 치명적인 영향을 주는 시스템을 의미합니다. 예를 들어, 무기제어, 미사일 자동조준 등의 제어시스템이 존재하며, 보장되는 컴퓨팅 시간의 정확성과 컴퓨팅에 대한 예측성을 가지게 해줘야 합니다.

**연성 실시간 시스템 (soft real-time system)?**

작업 실행에 대한 시간 제약을 지키지 못하더라도 전체 시스템에 큰 영향을 끼치지 않는 시스템을 의미합니다. 시간 제약을 만족시키는데 있어 어느정도 융통성을 갖고 있으며, 무효화 처리 또는 복구 등을 통해 재가동할 수 있습니다. 예를 들어, DVD 재생기 컴퓨터, 네트워크 등 있습니다. 

**임베디드 시스템?**

특정한 기능을 수행하기 위해 하드웨어와 소프트웨어가 내장된 전자 제어 시스템으로, 단순 회로만으로 구성된 장치가 아닌 마이크로프로세서가 내장되어 있으며 이를 통해 원하는 작업을 수행하고 관리하는 프로그램이 포함된 시스템입니다.

**교차개발 환경?**

target시스템은 일반적으로 메모리 용량이 매우 적어서 컴파일러를 포함한 개발환경을 올리기가 어렵습니다.

target 시스템 용 프로그램을 별도의 host 시스템에서 개발하는 환경을 의미합니다. host와 target에 사용되는 프로세서가 다른 경우, 컴파일러의 실행은 host에서 되지만 실행코드는 target system에서 실행됩니다.

교차 개발 환경에서 작업을 하기 위해서는 cross compiler가 필요합니다. 이는 target system용 실행 파일을 생성하는 컴파일러입니다.

**펌웨어**

하드웨어를 제어하는 마이크로 프로그램을 의미한다. 프로그램이라는 관점에서 소프트웨어와 동일하지만 하드웨어와 밀접한 관계를 가지고 있다는 점에서 일반 응용소프트웨어와 구분되며, 소프트웨어와 하드웨어의 특성을 모두 가진다. (하드웨어적인 소프트웨어)

모든 기능에 대해 제어하는 회로를 하드웨어로 만들면 구조가 매우 복잡하고 논리적으로 표현하기 어려운 부분도 발생한다. 상당 부분을 소프트웨어로 대체하되 해당 소프트웨어가 저장된 기억장치를 하드웨어의 제어 회로중의 중심부분으로 구성하면 매우 간단하면서 적은비용으로 해결가능하다. 

**멀티 태스킹**

여러개의 태스크를 동시에 실행하는 것으로,

일반 os에서 각 태스크는 대부분 무관한 프로그램인 반면,

임베디듣 시스템에서의 태스크는 하나의 큰 응용 프로그램을 논리적으로 나눈 것으로 기능상 매우 밀접한 관계를 가지고 태스크 사이에 이루어지는 작업들이 많습니다. 이에 응용 프로그램 실행을 위해 동시 실행될 필요가 있습니다.

**context switching**

현재 수행 중인 태스크의 시스템 상태를 TCB라는 특정한 구조체에 저장하고, 다음 새로운 태스크의 문맥을 가져와 시스템의 상태를 복원한 후 실행하는 것을 말합니다.

context switching은 overhead가 크기 때문에 짧을 수록 효율적이고 thread의 개념을 통해 보완할 수 있습니다.

**프로세스 vs 쓰레드**

프로세스란 운영체제로부터 시스템 자원을 할당받는 작업의 단위로 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 입니다. 운영체제로부터 독립된 메모리 영역을 할당 받으며, 각 프로세스당 stack, data, heap, code영역이 구분되어 있습니다. 때문에 다른 프로세스의 자원에 접근하기 위해 IPC를 사용해야 합니다. 문맥교환시 오버헤드가 큰 단점이 있지만 한 프로세스가 문제발생하더라도 전체에 영향을 미치지 않는 장점이 존재합니다.

쓰레드란 프로세스 내에서 동작하는 여러 실행의 흐름으로 프로세스 내에서 stack만 따로 할당 받고 나머지 영역은 공유합니다. 프로세스 내의 주소공간이나 자원들을 같은 프로세스내에 존재하는 쓰레드끼리 공유하여 실행할 수 있기 때문에 오버헤드가 멀티프로세스에 비해 적습니다. 하지만, 변수 공유로 주의 깊은 설계가 필요하고 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받습니다.

**멀티쓰레드 사용이유**

쓰레드간 메모리 공유로 시스템 자원 소모가 줄어들며, 자원할당 시스템 콜이 줄어들어 효율적관리가 가능합니다.

또한, IPC에 비해 쓰레드 간의 통신의 비용이 적어 작업들 간 통신의 부담이 줄어들고 문맥전환 속도가 빨라 응답 시간을 단축할 수 있습니다.

하지만, 주의할 점으로 공유변수 사용시 발생할 수 있는 동기화 문제가 있습니다.

**테스크간 통신**

테스크 통신으로 전역변수를 사용하는 세마포어, 뮤텍스가 있고, message 전달로는 mailbox, queue, pipe가 있습니다.

테스크 동기화로는 세마포, 이벤트 플래그, 시그널이 존재합니다.

**재진입 코드 (reentrance code)**

하나의 함수를 여러 태스크가 동시에 실행 가능할 때, 동시에 언제 접근해도 항상 같은 결과를 보장하는 코드를 의미합니다. 즉, 태스크1이 함수1을 실행하는 도중 태스크2로 문맥교환되고 태스크2가 함수1를 실행한 뒤 태스크1의 함수1실행으로 되돌아간다고 할 때 함수1의 실행은 모두 정상 동작할경우입니다.

재진입하지 못하는 코드는 공유하지 않거나 공유할 경우 세마포 쓰기, 동일 우선순위 갖는 태스크 사이애 round-robin사용하지 않아야 합니다.

**microC/OS-II**

학교나 개인의 교육과 같은 비상업적 목적에 한해 자유로이 사용 가능한 공개 소스로 소스코드의 수정 및 커널의 내부 구조를 이해하기가 용이한 실시간 운영체제입니다.

선점형 실시간 코드로 높은 우선순위 작업이 먼저 수행됩니다. 멀티태스킹을 지원하면 최대 64개의 태스크를 지원하고 일부 2개의 task는 os에서 사용하기 위해 지정되어있습니다.

일반 운영체제와 달리 kernel모드와 user모드가 구분되어 있지 않고 모든 task들이 kernel 모드에서 동작합니다.

이미 64개의 task가 생성되어 있고 task생성함수 호출시 ready상태로 진입하게 됩니다.

한 태스크가 ready list에 존재하는지 확인 및 현재 할당된 가장 높은 우선순위의 task를 찾기 O(1)에 하기위해 bitmap을 이용합니다.

**인터럽트**

비동기적 이벤트가 발생함을 CPU에서 알려주는 하드웨어 매커니즘으로, ISR로 문맥전호나 후 가장 높은 우선순위의 태스크가 다음 수해되도록 조정합니다.

인터럽트 지연시간 = 인터럽트에 반응해 ISR을 수행하기 전까지의 시간 = 인터럽트가 꺼져있는 최대시간 + ISR수행하는데 필요 시간

인터럽트 응답시간 = 인터럽트 반응해 ISR 수행하기까지의 시간 = 지연시간 + CPU문맥저장시간 + 커널의 ISR진입함수 수행하는 걸리는 시간

인터럽트 복구시간 = cpu 내용 되돌리는 시간 + 태스크 선택시간 + 돌아가는 시간

**스케쥴러**

RTOS에서 각 task는 데드라인이 정해져있으며 그 기한내에 종료할 필요가 있다. 적시성이 보장되어야 한다.

real-time scheudiling으로는 rate-monotonic scheduling과 earliest deadline first scheduling이 존재합니다.

rate-monotonic scheduling은 기본적으로 정적 우선순위 스케쥴링 알고리즘으로, 데드라인이 짧은 task순서로 우선순위를 지정합니다. uitilization이 n(2^(1/n)-1)보다 작거나 같으면 무조건 해당 task set은 실현가능하며, 만족하지 않더라도 1보다 작다면 실형가능할 수 있습니다.

deadlinke first scheduling은 기본적으로 동적 우선순위 스케쥴링 알고리즘으로 현 시간에 데드라인에 가장 근접한 task순으로 우선순위가 바뀌게 됩니다. task가 완료되는 시점마다 우선순위가 재계산됩니다. 실현가능 필요충분 조건으로는 utilization이 1보다 작거나 같은 경우 입니다.

**실시간 스케쥴링의 문제점과 해결책**

**우선순위 전도현상**? 고정 우선순위 선점형 스케쥴링에서 높은 우선순위의 태스크가 낮은 우선순위 태스크에 의해 블럭킹되는 현상을 의미하며, 공유된 자원을 사용할 때 발생될 수 있습니다. 해결책으로 임시로 낮은 우선순위 task가 높은 우선순위 task의 우선순위를 상속받는 **우선순위 계승 프로토콜**이 존재합니다.

**우선순위 계승 프로토콜**(PIP)? 이행적 성질을 가지고 있으며 우선순위 전도현상에 의해 발생하는 indefinite blocking문제를 해결할 수 있다. 어떤 태스크가 높은 우선순위의 태스크를 블럭시켰을 경우 그 태스크에 의해 블럭된 태스크 중 가장 높은 우선순위를 갖는 태스크의 우선순위를 상속받습니다. 이에 대한 문제로 이행 블록킹(직접 관련 없는 task를 기다리기 위한 시간 발생), 데드락이 발생할 수 있고 해결책으로 **우선순위 상한 프로토콜**이 존재합니다.

**우선순위 상한 프로토콜?** 자원에 우선순위가 생긴 것으로 모든 자원에 대해 해당 자원을 쓰려는 태스크중 가장 높은 우선순위로 우선순위 상한 값을 지정한다. 이후 실제 스케쥴링이 진행되면서, 현재 자신을 제외한 다른 태스크에 의해 락아 걸려있는 자원이 있는지 확인 후 해당 자원들의 상한 값의 최대값과 나의 우선순위를 비교해 내가 더크면 진입하고 아니면 block처리된다.

우선순위가 낮은 job이 선점하지 못하게 하기 위해 더 높은 우선순위 먼저 수행하기 위한 방법이다.

**ARM processor**

Advanced RISC Machine의 줄임말이다. RISC란 명령어 구조를 간단하게 하여 처리 속도가 빠르고 발열이 적다는 장점이 있다. 대부분의 임베디드 보드가 RISC에서 사용한다.

ARM은 현재 임베디드 기기에 가장 많이 쓰이는 프로세서

**CISC vs RISC**

CISC (Complex Instruction Set Computer)는 명령어의 길이가 가변적으로 구성된 CPU아키텍처이다. 명령어가 복잡하기 때문에 명령어를 해석하는데 오랜 시간이 걸리며, 명령어 해석에 필요한 회로도 복잡하다. 컴파일러 작성이 쉽고 호환성이 좋은 장점이 있다.

RISC (Reduced Instruction Set Computer)는 CPU에서 수행하는 동작 대부분이 몇개의 명령어 만으로 가능하다는 사실에 기반하여 구현되어, CPU명렁어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만드는 방식입니다. 고정된 길이의 명렁어를 사용하고 복잡한 명령어 경우 보유 명령어를 조합해 사용합니다.  컴파일러의 최적과 과정이 복잡하고 고정길이로 코드 효율이 낮은 단점이 있지만, 각 명령어가 한 클럭에 실행되도록 고정되어 파이프라인 성능에 최적화되어이씨고 디코딩 속도가 빠르며 여러 명령어를 한번에 처리할 수 있다.