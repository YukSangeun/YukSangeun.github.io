<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-19T18:59:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Portfolio</title><subtitle>공부, 프로젝트 등을 기록하기 위한 저장 공간.</subtitle><author><name>육상은</name></author><entry><title type="html">Dijkstra(다익스트라)</title><link href="http://localhost:4000/algorithm/dijkstra/" rel="alternate" type="text/html" title="Dijkstra(다익스트라)" /><published>2020-02-19T00:00:00+09:00</published><updated>2020-02-20T03:19:00+09:00</updated><id>http://localhost:4000/algorithm/dijkstra</id><content type="html" xml:base="http://localhost:4000/algorithm/dijkstra/">&lt;p&gt;다익스트라 알고리즘은 최단 경로 알고리즘(다익스트라, 벨만-포드, 플로이드) 중 하나이다.&lt;br /&gt;
이후 플로이드 알고리즘에 대한 글을 작성할 예정이며, 벨만-포드는 잘 사용되지 않으므로 넘어간다.&lt;/p&gt;

&lt;h2 id=&quot;최단-경로-문제&quot;&gt;최단 경로 문제&lt;/h2&gt;
&lt;p&gt;주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가중치가 없는 그래프의 경우 BFS로 찾기가 가능하다.&lt;/li&gt;
  &lt;li&gt;가중치가 있는 그래프 경우 dijkstra를 이용한다.&lt;/li&gt;
  &lt;li&gt;방향 그래프를 기준으로 수행할 것이며, 무방향 그래프일 경우 선을 두개의 방향 선으로 쪼개어 방향 그래프로 만든다.&lt;/li&gt;
  &lt;li&gt;ex) a - b ==&amp;gt; a -&amp;gt; b , b -&amp;gt; a 두가지 방향을 쪼갠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;가중치가-있는-그래프&quot;&gt;가중치가 있는 그래프&lt;/h2&gt;
&lt;p&gt;간선(u,v)의 가중치를 w(u,v)로 표기하며, 최단 경로 찾는 알고리즘은 크게 두가지 유형으로 나뉜다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;단일 시작점 알고리즘: 하나의 시작점에서 다른 모든 정점까지 가는 최단 거리를 구한다.(다익스트라)&lt;/li&gt;
  &lt;li&gt;모든 쌍 알고리즘: 모든 정점의 쌍에 대한 최단 거리를 계산한다.(플로이드)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt; - 가중치 그래프의 경우 음수 간선이 존재할 수 있고 다익스트라를 이용시 최단 경로를 정확하게 찾을 수 없다.( 음수 사이클이 발생할 수 있기 때문)&lt;br /&gt;
따라서 음수 간선이 존재하는 경우에는 다익스트라 알고리즘을 사용할 수 없으며 이 경우 &lt;strong&gt;벨만-포드, 플로이드 알고리즘&lt;/strong&gt;을 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h2&gt;
&lt;p&gt;단일 시작점 최단 경로 알고리즘으로 BFS와 유사하다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;차이점
    &lt;ul&gt;
      &lt;li&gt;시작점과 거리가 짧은 순서에 있는 노드부터 사용할 것이기 때문에 우선순위 큐(prirority queue)를 사용하여 {-거리, 정점} 형식으로 저장한다.&lt;/li&gt;
      &lt;li&gt;우선순위 큐는 내림차순 정렬이므로 거리가 짧은 순으로 찾기 위해 거리에 &lt;strong&gt;-&lt;/strong&gt;를 붙여 저장한다.&lt;/li&gt;
      &lt;li&gt;BFS 경우 visited[]배열을 사용하여 방문된 경우 다시 방문하지 않지만, 다익스트라는 각 정점까지의 최단 거리가 갱신될 수 있으므로 dist[]배열을 이용하여 더 짧은 거리를 찾는 경우 다시 방문한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우선순위 큐는 정점까지의 최단 거리를 기준으로 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로부터의 거리가 가장 가까운 점을 찾는 과정을 간단하게 해준다.&lt;/li&gt;
  &lt;li&gt;알고리즘 작동 방식
    &lt;ol&gt;
      &lt;li&gt;아직 방문하지 않은 정점들 중 거리가 가장 짧은 정점을 하나 선택해 방문한다.&lt;/li&gt;
      &lt;li&gt;해당 정점에서 인접하고 아직 방문하지 않은 정점들의 거리를 갱신한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드(백준 1753번 최단 경로)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   using namespace std;
	  
   int maxV = 1000000000;	//시작 노드부터의 가장 긴 길이 설정
   int V, E, K;	//노드 수, 간선 수, 시작 번호
   vector&amp;lt; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; adj;
   vector&amp;lt;int&amp;gt; dist;

   void dijkstra() {
        priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; pq;	//{-거리, 노드번호}
        dist[K-1] = 0;
        pq.push({ 0, K-1 });
        while(!pq.empty()) {
             int here = pq.top().second;
             int cost = -pq.top().first;
             pq.pop();
             if(dist[here] &amp;lt; cost) continue;	//기존에 찾은 경로가 더 짧은 경로일 경우 pass
             for( auto next : adj[here] ) {
                  int nextD = cost + next.second;
                  if( dist[next.first] &amp;gt; nextD )	//현재 찾은 경로가 더 짧은 경로인 경우
                       dist[next.first] = nextD; //갱신
                       pq.push({-nextD, next.first});
                  }
             }
        }
   }
	  
   int main() {
        scanf(&quot;%d %d %d&quot;, &amp;amp;V, &amp;amp;E, &amp;amp;K);
        adj.resize(V);
        dist.resize(V);
        for( int i = 0; i &amp;lt; E; i++ ) {
             int u, v, w;
             scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
             adj[u-1].push_back({v-1, w});
        }
        //dist배열 초기화
        for(int i = 0; i &amp;lt; V; i++) dist[i] = maxV;
        dijkstra();
        for(int i = 0; i &amp;lt; V; i++) {
             if ( dist[i] == maxV ) printf(&quot;INF\n&quot;);
             else printf(&quot;%d\n&quot;, dist[i]);
        }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;시간복잡도 O(ElogV)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="Graph" /><summary type="html">최단 경로 알고리즘</summary></entry><entry><title type="html">Parametric Search</title><link href="http://localhost:4000/algorithm/parametric-search/" rel="alternate" type="text/html" title="Parametric Search" /><published>2020-02-18T00:00:00+09:00</published><updated>2020-02-18T21:59:00+09:00</updated><id>http://localhost:4000/algorithm/parametric-search</id><content type="html" xml:base="http://localhost:4000/algorithm/parametric-search/">&lt;p&gt;Binary Search를 응용한 방법이며, 기본적인 탐색 방법은 Binary Search와 비슷하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;차이&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;알고리즘&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;탐색범위&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;수행&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;binary search&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;배열 값들을 기준으로 탐색&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mid값과의 일치여부로 판단&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;parametric search&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;실수 범위에서 이진탐색&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;비교함수 사용하여 판단&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;parametric search은 주로 내가 원하는 조건을 만족하는 가장 알맞은 값을 특정한 오차범위 이내에서 알고자 할 때 사용한다.&lt;br /&gt;
ex) y = x^2 + x + 1라는 식이 주어질 때, 1&amp;lt;x&amp;lt;10, y = 5인 경우에 해당하는 x를 구해라.&lt;br /&gt;
이때 비교함수는 &lt;strong&gt;5 = x^2 + x + 1&lt;/strong&gt;이 되며 x범위에 대해 식에 값을 넣어 5보다 큰지, 작은지 여부를 따지며 x를 찾는다.&lt;/p&gt;

&lt;p&gt;Parametric search의 경우는 일반적인 구현이 없고 문제에 따라 비교함수를 적절히 만들어야 한다.&lt;br /&gt;
&lt;strong&gt;주의&lt;/strong&gt;: mid값 구할 때 (+)에서 오버플로우 발생하지 않도록 long long 자료형을 이용하자&lt;/p&gt;

&lt;h2 id=&quot;예제-백준-2805번-나무자르기&quot;&gt;예제 (백준 2805번 나무자르기)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	  #include&amp;lt;stdio.h&amp;gt;
	  #include&amp;lt;vector&amp;gt;
	  using namespace std;
	  /*
	  [start - 조건을 만족하는 최대 높이, end - 조건을 불만족하는 최소 높이]
	  sum - mid로 나무들 절단 후 가져갈 총 길이 합
	  sum &amp;gt;= m : 높이 mid에서 조건 만족하므로 start = mid
	  sum &amp;lt; m : 높이 mid에서 조건 불만족하므로 end = mid
	  (start, end) 사이에 중간값 없을 경우 start값이 답 
	  */
	  
	  int func(vector&amp;lt;int&amp;gt; tree, int start, int end, int m) {	//나무 높이 정보, 시작범위, 끝 범위
	       while (end - start &amp;gt; 1) {	//범위가 (start, start+1)이전까지
	       int mid = (start + end) / 2;
	       long long sum = 0;
	       //분리된 나무 총 길이
	       for (int i = 0; i &amp;lt; tree.size(); i++)
	            sum += ((tree[i] - mid) &amp;gt; 0 ? tree[i] - mid : 0);
	       if (sum &amp;gt;= m)	//mid로 m 이상의 길이 가져갈 수 있음
	            start = mid;
	       else //mid로 m 이상의 길이 가져갈 수 없음
	            end = mid;
	       }
	       return start;
	  }
	  
	  int main() {
	       int n, m;	//나무의 수, 가져가고 싶은 나무 길이
	       int maxT = 0;	//최대 나무 높이(초기 범위 지정시 사용)
	       vector&amp;lt;int&amp;gt; tree;
	  
	       scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
	       tree.resize(n);
	       for (int i = 0; i &amp;lt; n; i++) {
	            scanf(&quot;%d&quot;, &amp;amp;tree[i]);
	       if (maxT &amp;lt; tree[i])	maxT = tree[i];
	       }
	       printf(&quot;%d&quot;, func(tree, 0, maxT, m));
	  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고&lt;br /&gt;
https://palyoung.tistory.com/40&lt;br /&gt;
https://m.blog.naver.com/PostView.nhn?blogId=kks227&amp;amp;logNo=220777333252&amp;amp;referrerCode=0&amp;amp;searchKeyword=binary%20search&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>육상은</name></author><category term="Binary Search" /><summary type="html">binary search를 응용한 탐색 방법</summary></entry><entry><title type="html">Binary Search(이진탐색/ 이분탐색)</title><link href="http://localhost:4000/algorithm/binary-serach/" rel="alternate" type="text/html" title="Binary Search(이진탐색/ 이분탐색)" /><published>2020-02-17T00:00:00+09:00</published><updated>2020-02-18T08:43:00+09:00</updated><id>http://localhost:4000/algorithm/binary-serach</id><content type="html" xml:base="http://localhost:4000/algorithm/binary-serach/">&lt;p&gt;탐색에는 기본적으로 순차 탐색이 있으며, 이 방법은 순차적으로 모든 데이터를 체크하여 값을 찾아가며 시간복잡도가 O(N)이다.&lt;br /&gt;
반면, 이진 탐색은 탐색 범위를 절반씩 줄여가며 찾아가는 탐색 방법으로 시간복잡도가 O(logN)이다.&lt;br /&gt;
&lt;strong&gt;point&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이진탐색의 경우 탐색하고자 하는 배열이 정렬되어 있어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;algorithm&lt;/strong&gt; 헤더에 존재하는 &lt;strong&gt;sort함수&lt;/strong&gt;를 사용하여 정렬을 수행하고 시간복잡도는 O(NlogN)이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;진행-순서&quot;&gt;진행 순서&lt;/h2&gt;
&lt;p&gt;arr[9] = {1, 2, 3, 7, 9, 12, 21, 23, 37} 에서 4를 찾는 경우&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;순차 탐색 경우: arr[0]부터 arr[8]까지 4와 일치여부를 모두 검사한다.&lt;/li&gt;
  &lt;li&gt;이분 탐색 경우: 초기 범위의 start=arr[0], end=arr[8]로 지정 후 범위의 중간인 arr[4]를 찾는 값과 비교하여 범위를 재지정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/binarySearch.PNG&quot; alt=&quot;이분 탐색 진행 순서&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;p&gt;이분 탐색은 일반 반복문 또는 재귀함수를 사용하여 나타낼 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;일반 반복문&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   int BinarySerach(int arr[], int target) {
        int start = 0;
        int end = arr.length - 1;
        int mid = (end + start) / 2;
        while(end &amp;gt;= start) {	//start가 end보다 값이 작거나 같은 경우 반복
             if( arr[mid] == target ) return mid;	//경우1: 배열에서 target 찾은 경우 위치 반환
             else if( arr[mid] &amp;lt; target ) start = mid + 1;	//경우2: target이 배열 중간보다 오른쪽인 경우
             else end = mid - 1;	//경우3: target이 배열 중간보다 왼쪽인 경우
             mid = (end + start) / 2;	//탐색 범위 재조정했으므로 mid값 다시 찾기
        }
        return -1;	//경우4: 배열속에서 target 못 찾은 경우
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재귀함수&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   int arr[];	//전역변수로 지정
   int BinarySerach(int start, int end, int target) {
        int mid = (end + start) / 2;
        if(start &amp;gt; end) return -1;	//경우4: 배열속에서 target 못 찾은 경우
        if( arr[mid] == target ) return mid;	//경우1: 배열에서 target 찾은 경우 위치 반환
        else if( arr[mid] &amp;lt; target ) start = mid + 1;	//경우2: target이 배열 중간보다 오른쪽인 경우
        else end = mid - 1;	//경우3: target이 배열 중간보다 왼쪽인 경우
	       
        BinarySearch(arr, start, end, target);	//범위 재조정 후 재귀 호출
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;p&gt;binarySearch 알고리즘은 실제로 &lt;strong&gt;algorithm&lt;/strong&gt;헤더에 존재한다.&lt;br /&gt;
사용이 많이 되므로 동작이 수행되는 방법을 알고 있는 것이 좋으며, 헤더에 존재하는 함수를 사용할 때와 직접 코드를 작성하여 사용하는 경우 둘 다 걸리는 시간이 똑같다.&lt;/p&gt;

&lt;p&gt;binarySearch 알고리즘의 일부를 살짝 수정하면 &lt;strong&gt;하한선/상한선&lt;/strong&gt;을 찾아주는 알고리즘을 만들 수 있다.&lt;br /&gt;
ex) 10 20 20 30 40 순으로 값이 배열되어 있을 때, target = 20이라 하자.&lt;br /&gt;
하한선의 경우: 20이상을 처음 찾는 위치를 반환하며 이 경우 위치 1에 해당한다.&lt;br /&gt;
상한선의 경우: 20을 초과하는 처음 위치를 반환하며 이 경우 위치 3에 해당한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;하한선 코드 (lower_bound)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   int lower_bound(int arr[], int target) {
        int start = 0;
        int end = arr.length - 1;
        while(start &amp;lt;= end) {
             int mid = (start + end) / 2;
             if(arr[mid] &amp;lt; target) start = mid + 1;
             else end = mid - 1;
        }
        return end+1;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상한선 코드 (upper_bound)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   int upper_bound(int arr[], int target) {
        int start = 0;
        int end = arr.length - 1;
        while(start &amp;lt;= end) {
             int mid = (start + end) / 2;
             if(arr[mid] &amp;lt;= target) start = mid + 1;
             else end = mid - 1;
        }
        return end+1;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;upper_bound/ lower_bound 역시 &lt;strong&gt;algorithm&lt;/strong&gt;헤더에 존재한다.&lt;/p&gt;

&lt;p&gt;binary_search(arr, arr+n, key);	반환형은 true/false&lt;br /&gt;
upper_bound(arr, arr+n, key);  반환형은 iterator&lt;br /&gt;
lower_bound(arr.begin(), arr.end(), key);  반환형은 iterator&lt;br /&gt;
벡터인 경우 lower_bound와 같은 형식으로 작성하면 되고, 일반 배열인 경우 나머지와 같은 형식으로 작성하면 된다.&lt;/p&gt;

&lt;p&gt;반환형이 iterator인 경우 현재 위치가 배열에서 몇 번째 위치인지를 확인하기 위해서는 벡터인 경우 iterator-v.begin(), 배열인 경우 iterator-arr을 하면 된다.&lt;br /&gt;
해당 위치에 있는 값을 출력하고 싶을 때는 printf(“%d”, *iterator); 와 같이 작성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;&lt;br /&gt;
항상 위 세가지 함수 모두 정렬을 한다음에 수행해야한다.&lt;/p&gt;</content><author><name>육상은</name></author><category term="Binary Search" /><summary type="html">탐색 범위를 절반씩 줄여가며 탐색하는 알고리즘</summary></entry><entry><title type="html">백준 1039번 교환</title><link href="http://localhost:4000/problem/bfs-problem1/" rel="alternate" type="text/html" title="백준 1039번 교환" /><published>2020-02-16T00:00:00+09:00</published><updated>2020-02-16T00:00:00+09:00</updated><id>http://localhost:4000/problem/bfs-problem1</id><content type="html" xml:base="http://localhost:4000/problem/bfs-problem1/">&lt;h2 id=&quot;문제&quot;&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1&amp;lt;= i &amp;lt; j &amp;lt;= M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 
이때, 바꾼 수가 0으로 시작하면 안된다.&lt;br /&gt;
위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;입력&quot;&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;첫째 줄에 정수 N과 K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, K는 10보다 작거나 같은 자연수이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;참조: https://www.acmicpc.net/problem/1039&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;탐색 시 깊이가 K번째인 경우까지만 탐색하므로 BFS 알고리즘을 사용한다.&lt;br /&gt;
초기 i번 째 깊이에서 교환하여 얻을 수 있는 값들을 모두 queue에 넣는 방식으로 탐색을 수행했지만(visited[]사용 없이) &lt;strong&gt;메모리 초과&lt;/strong&gt;가 발생했다.&lt;br /&gt;
즉, &lt;strong&gt;방문 여부를 확인하여&lt;/strong&gt; 방문된 곳은 queue에 넣지 않는 방식을 사용하여 문제를 풀어야 한다.&lt;br /&gt;
같은 깊이의 값들을 탐색 후 k를 감소시키는 방식을 사용하였으며 k==0인 경우 탐색을 종료하고 탐색시 찾은 최고 높은 값을 반환한다.&lt;/p&gt;

&lt;p&gt;깊이별 포함된 값들을 생각해보자.  (깊이 i)&lt;br /&gt;
i가 홀수인 경우 값 num을 i번 교환하여 얻을 수 있는 값들의 집합은  (i번째에서 교환하여 찾은 값들 + 깊이i 이전 홀수번째 깊이들에서 가능했던 값들)이다.&lt;br /&gt;
마찬가지로 i가 짝수인 경우 값 num을 i번 교환하여 얻을 수 있는 값들의 집합은 (i번째 교환하여 찾은 값들 + 깊이i 이전 짝수번째 깊이들에서 가능했던 값들)이다.&lt;br /&gt;
즉, 홀수끼리 집합이 형성되고 짝수끼리 집합이 형성된다.&lt;br /&gt;
따라서 우리는 최댓값을 찾을 때, &lt;strong&gt;홀수깊이에서의 최댓값과 짝수깊이에서의 최댓값을 따로 구해야한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 언급한 것과 같이 탐색할 때 k를 감소시키는 방향으로 했다. (k가 짝수인 경우, 홀수인 경우를 생각해보자&lt;br /&gt;
k=3인 경우&lt;br /&gt;
–&amp;gt; k=3일 때 같은 깊이 값들 탐색, k=2일 때 같은 깊이 값들 탐색, k=1일 때 같은 깊이 값들 탐색, k=0일 때 탐색 종료 후 반환&lt;br /&gt;
k=2인 경우&lt;br /&gt;
–&amp;gt; k=2일 때 같은 깊이 탐색, k=1일 때 같은 깊이 탐색, k=0일 때 탐색 종료 후 반환&lt;br /&gt;
k가 짝수, 홀수인 경우 두 경우를 모두 볼 때 최종적으로 k=1일 때까지만 탐색을하게 된다.&lt;br /&gt;
즉, 위에서 최댓값을 찾을 때 홀수깊이, 짝수깊이에서의 각각 최댓값을 찾으면 된다했지만 실제로 우리가 사용하는 것은 k의 값이 홀수인 깊이들이다.&lt;br /&gt;
따라서 우리는 k의 값이 홀수인 깊이들에 대해서만 값들을 비교하여 최댓값을 찾으면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;소스코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include&amp;lt;stdio.h&amp;gt;
    #include&amp;lt;queue&amp;gt;
    using namespace std;
	  
    bool visited[1000001];	//방문 여부
    int m = -1, k;	//입력받은 값의 자리수, 교환 횟수
    char arr[7];	//값 num에 대한 교환을 쉽게 하기 위해 각 자리 수마다 배열에 넣기
    int num;
	  
    queue&amp;lt;int&amp;gt; qu;
    int bfs() {
         int maxxO = -1;	//k가 홀수 일 때 최댓값
         while (!qu.empty()) {	//이때 qu에는 깊이가 같은 값들만 들어있다.
              int size = qu.size();
              while (size--) {	//깊이가 같은 값들에 대해서 탐색 수행
                   num = qu.front();
                   qu.pop();
                   for (int i = 0; i &amp;lt;= m; i++) {
                        arr[i] = '0' + num % 10;
                        num = num / 10;
                   }
                   //swap
                   for (int i = m; i &amp;gt;= 0; i--) {
                        for (int j = i - 1; j &amp;gt;= 0; j--) {
                             if (arr[j] == '0' &amp;amp;&amp;amp; i == m) continue;
                             char tem = arr[j];	// i, j번째 자리 교환
                             arr[j] = arr[i];
                             arr[i] = tem;
                             num = 0;
                             for (int l = m; l &amp;gt;= 0; l--)
                                  num = num * 10 + (arr[l] - '0');
                             arr[i] = arr[j];	//교환된 값은 num에 저장했으므로 원래 자리로 원위치하여 다음 교환을 가능하게 한다.
                             arr[j] = tem;
                             if (k % 2 == 1 &amp;amp;&amp;amp; maxxO &amp;lt; num)	//k가 홀수일 때 값을 비교한다.
                                  maxxO = num;
                             if (visited[num]) continue;
                             visited[num] = true;
                             qu.push(num);
                                   }
                   }
              }
              k--;	//같은 깊이 수행 후 k감소
              if (k == 0) break;	//k번 수행 완료한 경우 탐색 중단
         }
         return maxxO;	//가장 큰 값을 반환한다.
    }
	  
    int main() {
         scanf(&quot;%d %d&quot;, &amp;amp;num, &amp;amp;k);
         qu.push(num);	//bfs()시작시 사용할 값을 미리 qu에 넣는다.
         while (num &amp;gt; 0) {	//자리수 세기 ex)1234일 경우, m=3 (0번부터 센다)
              m++;
              num = num / 10;
         }
         printf(&quot;%d&quot;, bfs());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="graph" /><summary type="html">BFS 알고리즘을 사용한 문제</summary></entry><entry><title type="html">DP(Dynamic Programming)</title><link href="http://localhost:4000/algorithm/dp/" rel="alternate" type="text/html" title=" DP(Dynamic Programming)" /><published>2020-02-16T00:00:00+09:00</published><updated>2020-02-17T00:15:00+09:00</updated><id>http://localhost:4000/algorithm/dp</id><content type="html" xml:base="http://localhost:4000/algorithm/dp/">&lt;h2 id=&quot;dpdynamic-programming---동적-계획법&quot;&gt;&lt;strong&gt;DP(Dynamic Programming) - 동적 계획법&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;큰 문제를 작은 문제로 나눠서 푸는&lt;/strong&gt; 기법을 의미하며, 참고로 알고리즘 이름과 의미는 별개이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;작은 문제들에 대해 계산한 값을 여러 번 사용할 수 있기 때문에 &lt;strong&gt;메모이제이션&lt;/strong&gt;이 필요&lt;/li&gt;
      &lt;li&gt;점화식을 잘 세우는 것이 중요(식과 초기 값)&lt;/li&gt;
      &lt;li&gt;종류: 1차 배열 dp, 2차 배열 dp …&lt;/li&gt;
      &lt;li&gt;(분할 정복과 차이: 분할 정복은 문제를 분할했을 때 겹치는 문제가 발생 안함)&lt;/li&gt;
      &lt;li&gt;ex) 이항계수(nCr)의 계산, 피보나치 수열(Fn = Fn-1 + Fn-2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시간 절약을 위한 Memoization
    &lt;ul&gt;
      &lt;li&gt;ex) 이항계수의 계산&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;점화식: Bino(a,b) = Bino(a-1, b) + Bino(a-1, b-1)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;bino(4,2)를 호출 시 bino()함수가 재귀적으로 호출&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bino(4,2) = bino(3,1) + bino(3,2)
bino(3,1) = bino(2,0) + bino(2,1)
bino(2,1) = bino(1,0) + bino(1,1)
bino(3,2) = bino(2,1) + bino(2,2)
bino(2,1) = bino(1,0) + bino(1,1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;위에 호출된 bino()함수를 볼 때 bino(2,1)이 중복적으로 호출된다. (bino(2,1)에 의해 그 밑 bino(1,0), bino(1,1)도 중복 호출된다.)&lt;/li&gt;
      &lt;li&gt;이 경우 중복된 계산 수행을 방지하여 시간 단축을 가능하게 하는 기법이 memoization이다.&lt;/li&gt;
      &lt;li&gt;계산된 결과를 배열에 저장한 뒤, 다음계산에서 필요한 경우 저장된 값을 불러와 불필요한 함수 호출 및 계산을 하지 않게 한다.&lt;/li&gt;
      &lt;li&gt;(시간 복잡도가 훨씬 줄어들게 됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DP 방식
    &lt;ul&gt;
      &lt;li&gt;Top-Down
        &lt;ul&gt;
          &lt;li&gt;일반 재귀와 같은 방식으로 위에서 아래로 내려오는 방식이며, memoization을 사용하기 위해 배열에 계산된 값들을 저장한다.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;백준 2747번 피보나치 수&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
using namespace std;
		  
int dp[45];	//-1로 초기화 (아직 값이 저장안됨을 의미)
int fbo(int n) {
     if ( dp[n] != -1 ) return dp[n];	//계산된 값 존재하는 경우
     dp[n] = fbo(n-1)+fbo(n-2);	//피보나치 수열 점화식 fbo(n) = fbo(n-1)+fbo(n-2);
     return dp[n];
}
int main() {
     int n;
     scanf(&quot;%d&quot;, &amp;amp;n);
     dp[0] = 0;	//초기값 설정 fbo(0), fbo(1)
     dp[1] = 1;
     for(int i=2; i&amp;lt;=n; i++) dp[i] = -1;
		  
     printf(&quot;%d&quot;, fbo(n));
}	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Bottom-Up
        &lt;ul&gt;
          &lt;li&gt;for문을 이용해서 처음 값부터 다음 값을 계산해 나가는 방식&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;백준 2747번 피보나치 수&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
using namespace std;
		  
int dp[45];  
		  
int main() {
     int n;
     scanf( &quot;%d&quot;, &amp;amp;n );
     dp[0] = 0;	//초기값 설정 fbo(0), fbo(1)
     dp[1] = 1;
     for(int i=2; i&amp;lt;=n; i++) 
          dp[i] = dp[i-1] + dp[i-2];
		  
     printf( &quot;%d&quot;, dp[n] );
}	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;차이
        &lt;ul&gt;
          &lt;li&gt;Top-down 방식에 메모이제이션을 했다는 가정하에 시간 복잡도는 같다.&lt;/li&gt;
          &lt;li&gt;하지만 재귀적으로 함수를 호출하는 과정 때문에 실제 걸리는 시간은 top-down DP가 더 길다고 알려져 있다.&lt;/li&gt;
          &lt;li&gt;Top-down DP의 장점: 점화식 그대로 호출이 되기 때문에 형식/순서에 얽매이지 않고 가독성이 좋다.&lt;/li&gt;
          &lt;li&gt;Bottum-Up DP의 장점: 함수를 호출하지 않으므로 시간/메모리 소량 절약&lt;/li&gt;
          &lt;li&gt;문제에 따라 둘 중 편한 방법을 사용하면 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="DP" /><summary type="html">큰 문제를 작은 문제들로 나눠서 푸는 기법</summary></entry><entry><title type="html">BFS Algorithm</title><link href="http://localhost:4000/algorithm/bfs/" rel="alternate" type="text/html" title="BFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/bfs</id><content type="html" xml:base="http://localhost:4000/algorithm/bfs/">&lt;h2 id=&quot;bfsbreadth-first-search---너비-우선-탐색&quot;&gt;&lt;strong&gt;BFS(Breadth First Search) - 너비 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BFS
    &lt;ul&gt;
      &lt;li&gt;시작점에 가까운 정점부터 순서대로 방문(모든 곳을 공평하게 조금씩 본다.)&lt;/li&gt;
      &lt;li&gt;즉 시작점을 0단계, 그 다음부터 1, 2, ..k..단계라고 할 때, &lt;strong&gt;k단계에 방문하는 정점들을 시작점으로부터 최단거리가 k라고 한다.&lt;/strong&gt;(A에서 B로 이동하는 데 필요한 최소 개수의 간선)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;최단경로 문제를 풀 때 유용하다.&lt;/strong&gt;  (깊이를 알 수 있으므로)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;각 정점들을 방문할 때마다 모든 인접 정점들을 검사&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: queue를 이용하여 방문할 list를 저장한다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서    
ex) 1 - 2 - 3 - 5 - 6 - 9  
        ㄴ  4   ㄴ  7 - 8  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;9-&amp;gt;8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 1260번 DFS와 BFS)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs(int start) {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[start] = true;	//방문되는 노드들 표시
        qu.push(start);
        while ( !qu.empty()) {
             int here = qu.front();
             printf(&quot;%d &quot;, here);	//방문 순서대로 출력
             qu.pop();
             //간선으로 연결된 다른 정점들 탐색
             for (int next : vt[start]) {
                  if (!visited[next]) {	//방문되지 않은 노드 경우 탐색
                       visited[next] = true;
                       qu.push(next);
                  }
             }
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //bfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        bfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 2644번 - 촌수계산(최단거리 이용문제))&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   using namespace std;
	
   int n, p1, p2;	//정점의 개수, 구하고자 하는 두 사람  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs() {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[p1-1] = true;	//방문되는 노드들 표시
        qu.push(p1-1);
        int level = 1;	//p1으로부터의 거리 체크
        while ( !qu.empty()) {	//이 부분에서는 항상 q에 있는 정점들은 같은 레벨
             int size = qu.size();	//같은 레벨에 속한 정점의 개수를 반환
             while(size--) {	//같은 레벨 정점들에 대해서 연결된 다른 노드들 검사
                  int here = qu.front();
                  qu.pop();
                  //간선으로 연결된 다른 정점들 탐색
                  for (int i = 0; i &amp;lt; vt[here].size(); i++) {
                       if (visited[vt[here][i]]) continue;
                       if (vt[here][i] == p2 - 1) return level;
                       visited[vt[here][i]] = true;
                       qu.push(vt[here][i]);
                  }
             }
             level++;
        }
        return -1;
   }
 
   int main() {
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;p1, &amp;amp;p2);
        visited.resize(n);	//노드 개수에 맞게 크기 조정
        vt.resize(n);
        scanf(&quot;%d&quot;, &amp;amp;n);
        while (n--) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a-1].push_back(b-1);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b-1].push_back(a-1);
        }
        printf(&quot;%d&quot;, bfs() );
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 너비 우선 탐색 알고리즘</summary></entry><entry><title type="html">DFS Algorithm</title><link href="http://localhost:4000/algorithm/dfs/" rel="alternate" type="text/html" title="DFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-15T00:15:00+09:00</updated><id>http://localhost:4000/algorithm/dfs</id><content type="html" xml:base="http://localhost:4000/algorithm/dfs/">&lt;h2 id=&quot;dfsdepth-first-search---깊이-우선-탐색&quot;&gt;&lt;strong&gt;DFS(Depth First Search) - 깊이 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
      &lt;li&gt;DFS는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DFS
    &lt;ul&gt;
      &lt;li&gt;현재 정점에서 더 이상 다른 정점으로 이동할 수 없는 상태에 도달할 때까지 탐색 후 이전 정점으로 돌아가 연결된 다른 정점에 대해 같은 방식으로 반복한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;더 이상 다른 정점으로 이동할 수 없을 때 이전 정점으로 돌아가므로 구현시 지금 까지 거쳐온 정점들을 모두 저장해둬야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: Stack을 이용한 push/pop  , 재귀함수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서  
ex) 1 - 2 - 3 - 5 - 6  
        ㄴ  4   ㄴ  7  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;5(back한 것)-&amp;gt;7-&amp;gt;5(back)-&amp;gt;3(back)-&amp;gt;2(back)-&amp;gt;4-&amp;gt;2(back)-&amp;gt;1(back)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;dfs는 대개 그래프 전체 구조를 파악하기 위해 사용 ex)연결된 부분집합의 개수 크기
        &lt;ul&gt;
          &lt;li&gt;부분집합 = component = 요소: 하나의 graph에는 1개 이상의 컴포넌트 존재&lt;/li&gt;
          &lt;li&gt;컴포넌트 하나 안에 속한 정점은 서로 모두 이어져 있으며, 다른 컴포넌트 끼리는 이어져 있지 않다.&lt;/li&gt;
          &lt;li&gt;또한 컴포넌트는 항상 가능한 최대의 크기&lt;/li&gt;
          &lt;li&gt;connected graph: 그래프의 컴포넌트가 단 하나인 경우로 모든 정점이 연결되어 있다.&lt;/li&gt;
          &lt;li&gt;찾는 방법: 노드 i에서 시작하는 dfs(i)탐색시 탐색 종료 후 i를 포함한 방문된 모든 노드들은 모두 하나의 컴포넌트에 속한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 1260번 DFS와 BFS)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void dfs(int start) {
        visited[start] = true;	//방문되는 노드들 표시
        printf(&quot;%d &quot;, start);	//방문 순서대로 출력
        //간선으로 연결된 다른 정점들 탐색
        for (int next : vt[start]) {
             if (!visited[next]) dfs(next);	//방문되지 않은 노드 경우 탐색
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //dfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        dfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="DFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 깊이 우선 탐색 알고리즘</summary></entry><entry><title type="html">Graph</title><link href="http://localhost:4000/data%20structure/graph/" rel="alternate" type="text/html" title="Graph" /><published>2020-02-13T00:00:00+09:00</published><updated>2020-02-13T11:14:00+09:00</updated><id>http://localhost:4000/data%20structure/graph</id><content type="html" xml:base="http://localhost:4000/data%20structure/graph/">&lt;h2 id=&quot;1-그래프-설명&quot;&gt;&lt;strong&gt;1. 그래프 설명&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현실세계에서는 도로망, 지인관계, 링크관계 등의 연결고리들을 표현할 수 있다.&lt;/li&gt;
  &lt;li&gt;정의: 정점(vertex)과 간선(edge)의 집합  G(V,E)&lt;/li&gt;
  &lt;li&gt;정점: 노드(node)라고도 부른다.&lt;/li&gt;
  &lt;li&gt;간선: 유형에 따라 나뉜다.
    &lt;ol&gt;
      &lt;li&gt;두 정점을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;자기자신을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;방향이 있는 간선/ 없는 간선 - 방향이 있는 간선의 경우 사이클 발생 가능&lt;/li&gt;
      &lt;li&gt;가중치가 있는/ 없는 간선&lt;/li&gt;
      &lt;li&gt;DAG: 여러 유형의 간선을 혼합한 것들 중 방향그래프이면서 사이클이 존재하는 그래프를 지칭&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_case.png&quot; alt=&quot;간선 유형에 따른 그림&quot; title=&quot;간선 유형에 따른 그림&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차수(degree): 한 정점에 이어진(인접한) 간선의 개수
    &lt;ul&gt;
      &lt;li&gt;인접하다(adjacent): 두 정점이 간선으로 이어져 있을 때를 의미&lt;/li&gt;
      &lt;li&gt;방향 그래프에서는 indegree(들어오는 간선 개수)/ outdegree(나가는 간선 개수)가 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;경로(path): 끝과 끝이 서로 연결된 간선들을 순서대로 나열할 것
    &lt;ul&gt;
      &lt;li&gt;단순 경로: 경로 중 한 점을 최대 한번만 지나도록 한 경로 / 특정 언급을 안할 경우 대부분 경로 찾기시 이것을 의미한다.&lt;/li&gt;
      &lt;li&gt;Cycle: 방향 그래프에서 많이 사용되는 개념/ 간선을 따라가다 시작한 정점으로 돌아오는 경로를 의미 (1-&amp;gt;2-&amp;gt;3-&amp;gt;1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프 표현 방법
    &lt;ul&gt;
      &lt;li&gt;간선의 정보 저장 방식에 따라 나뉨&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접리스트 표현: vector&amp;lt;vector&lt;int&gt;&amp;gt; list;&lt;/int&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V+E)    
간선의 수 적은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접행렬 표현: vector&amp;lt;vector&lt;bool&gt;&amp;gt; matrix; 또는 int matrix[][];&lt;/bool&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V*V)  
두 정점간 연결 유무를 바로 알수 있다.  
간선의 수가 많은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_declare.png&quot; alt=&quot;정보 저장 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="DFS" /><category term="graph" /><summary type="html">DFS, BFS에서 사용되는 그래프 자료구조에 대한 설명</summary></entry></feed>