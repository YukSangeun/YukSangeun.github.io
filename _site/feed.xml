<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-14T17:18:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Portfolio</title><subtitle>공부, 프로젝트 등을 기록하기 위한 저장 공간.</subtitle><author><name>육상은</name></author><entry><title type="html">BFS Algorithm</title><link href="http://localhost:4000/algorithm/bfs/" rel="alternate" type="text/html" title="BFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/bfs</id><content type="html" xml:base="http://localhost:4000/algorithm/bfs/">&lt;h2 id=&quot;bfsbreadth-first-search---너비-우선-탐색&quot;&gt;&lt;strong&gt;BFS(Breadth First Search) - 너비 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BFS
    &lt;ul&gt;
      &lt;li&gt;시작점에 가까운 정점부터 순서대로 방문(모든 곳을 공평하게 조금씩 본다.)&lt;/li&gt;
      &lt;li&gt;즉 시작점을 0단계, 그 다음부터 1, 2, ..k..단계라고 할 때, &lt;strong&gt;k단계에 방문하는 정점들을 시작점으로부터 최단거리가 k라고 한다.&lt;/strong&gt;(A에서 B로 이동하는 데 필요한 최소 개수의 간선)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;최단경로 문제를 풀 때 유용하다.&lt;/strong&gt;  (깊이를 알 수 있으므로)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;각 정점들을 방문할 때마다 모든 인접 정점들을 검사&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: queue를 이용하여 방문할 list를 저장한다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서    
ex) 1 - 2 - 3 - 5 - 6 - 9  
        ㄴ  4   ㄴ  7 - 8  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;9-&amp;gt;8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 16881461번)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs(int start) {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[start] = true;	//방문되는 노드들 표시
        qu.push(start);
        while ( !qu.empty()) {
             int here = qu.front();
             printf(&quot;%d &quot;, here);	//방문 순서대로 출력
             qu.pop();
             //간선으로 연결된 다른 정점들 탐색
             for (int next : vt[start]) {
                  if (!visited[next]) {	//방문되지 않은 노드 경우 탐색
                       visited[next] = true;
                       qu.push(next);
                  }
             }
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //bfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        bfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 17652404번 - 촌수계산(최단거리 이용문제))&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   using namespace std;
	
   int n, p1, p2;	//정점의 개수, 구하고자 하는 두 사람  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs() {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[p1-1] = true;	//방문되는 노드들 표시
        qu.push(p1-1);
        int level = 1;	//p1으로부터의 거리 체크
        while ( !qu.empty()) {	//이 부분에서는 항상 q에 있는 정점들은 같은 레벨
             int size = qu.size();	//같은 레벨에 속한 정점의 개수를 반환
             while(size--) {	//같은 레벨 정점들에 대해서 연결된 다른 노드들 검사
                  int here = qu.front();
                  qu.pop();
                  //간선으로 연결된 다른 정점들 탐색
                  for (int i = 0; i &amp;lt; vt[here].size(); i++) {
                       if (visited[vt[here][i]]) continue;
                       if (vt[here][i] == p2 - 1) return level;
                       visited[vt[here][i]] = true;
                       qu.push(vt[here][i]);
                  }
             }
             level++;
        }
        return -1;
   }
 
   int main() {
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;p1, &amp;amp;p2);
        visited.resize(n);	//노드 개수에 맞게 크기 조정
        vt.resize(n);
        scanf(&quot;%d&quot;, &amp;amp;n);
        while (n--) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a-1].push_back(b-1);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b-1].push_back(a-1);
        }
        printf(&quot;%d&quot;, bfs() );
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 너비 우선 탐색 알고리즘</summary></entry><entry><title type="html">DFS Algorithm</title><link href="http://localhost:4000/algorithm/dfs/" rel="alternate" type="text/html" title="DFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-15T00:15:00+09:00</updated><id>http://localhost:4000/algorithm/dfs</id><content type="html" xml:base="http://localhost:4000/algorithm/dfs/">&lt;h2 id=&quot;dfsdepth-first-search---깊이-우선-탐색&quot;&gt;&lt;strong&gt;DFS(Depth First Search) - 깊이 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
      &lt;li&gt;DFS는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DFS
    &lt;ul&gt;
      &lt;li&gt;현재 정점에서 더 이상 다른 정점으로 이동할 수 없는 상태에 도달할 때까지 탐색 후 이전 정점으로 돌아가 연결된 다른 정점에 대해 같은 방식으로 반복한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;더 이상 다른 정점으로 이동할 수 없을 때 이전 정점으로 돌아가므로 구현시 지금 까지 거쳐온 정점들을 모두 저장해둬야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: Stack을 이용한 push/pop  , 재귀함수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서  
ex) 1 - 2 - 3 - 5 - 6  
        ㄴ  4   ㄴ  7  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;5(back한 것)-&amp;gt;7-&amp;gt;5(back)-&amp;gt;3(back)-&amp;gt;2(back)-&amp;gt;4-&amp;gt;2(back)-&amp;gt;1(back)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;dfs는 대개 그래프 전체 구조를 파악하기 위해 사용 ex)연결된 부분집합의 개수 크기
        &lt;ul&gt;
          &lt;li&gt;부분집합 = component = 요소: 하나의 graph에는 1개 이상의 컴포넌트 존재&lt;/li&gt;
          &lt;li&gt;컴포넌트 하나 안에 속한 정점은 서로 모두 이어져 있으며, 다른 컴포넌트 끼리는 이어져 있지 않다.&lt;/li&gt;
          &lt;li&gt;또한 컴포넌트는 항상 가능한 최대의 크기&lt;/li&gt;
          &lt;li&gt;connected graph: 그래프의 컴포넌트가 단 하나인 경우로 모든 정점이 연결되어 있다.&lt;/li&gt;
          &lt;li&gt;찾는 방법: 노드 i에서 시작하는 dfs(i)탐색시 탐색 종료 후 i를 포함한 방문된 모든 노드들은 모두 하나의 컴포넌트에 속한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 16881461번)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void dfs(int start) {
        visited[start] = true;	//방문되는 노드들 표시
        printf(&quot;%d &quot;, start);	//방문 순서대로 출력
        //간선으로 연결된 다른 정점들 탐색
        for (int next : vt[start]) {
             if (!visited[next]) dfs(next);	//방문되지 않은 노드 경우 탐색
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //dfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        dfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="DFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 깊이 우선 탐색 알고리즘</summary></entry><entry><title type="html">Graph</title><link href="http://localhost:4000/data%20structure/graph/" rel="alternate" type="text/html" title="Graph" /><published>2020-02-13T00:00:00+09:00</published><updated>2020-02-13T11:14:00+09:00</updated><id>http://localhost:4000/data%20structure/graph</id><content type="html" xml:base="http://localhost:4000/data%20structure/graph/">&lt;h2 id=&quot;1-그래프-설명&quot;&gt;&lt;strong&gt;1. 그래프 설명&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현실세계에서는 도로망, 지인관계, 링크관계 등의 연결고리들을 표현할 수 있다.&lt;/li&gt;
  &lt;li&gt;정의: 정점(vertex)과 간선(edge)의 집합  G(V,E)&lt;/li&gt;
  &lt;li&gt;정점: 노드(node)라고도 부른다.&lt;/li&gt;
  &lt;li&gt;간선: 유형에 따라 나뉜다.
    &lt;ol&gt;
      &lt;li&gt;두 정점을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;자기자신을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;방향이 있는 간선/ 없는 간선 - 방향이 있는 간선의 경우 사이클 발생 가능&lt;/li&gt;
      &lt;li&gt;가중치가 있는/ 없는 간선&lt;/li&gt;
      &lt;li&gt;DAG: 여러 유형의 간선을 혼합한 것들 중 방향그래프이면서 사이클이 존재하는 그래프를 지칭&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_case.png&quot; alt=&quot;간선 유형에 따른 그림&quot; title=&quot;간선 유형에 따른 그림&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차수(degree): 한 정점에 이어진(인접한) 간선의 개수
    &lt;ul&gt;
      &lt;li&gt;인접하다(adjacent): 두 정점이 간선으로 이어져 있을 때를 의미&lt;/li&gt;
      &lt;li&gt;방향 그래프에서는 indegree(들어오는 간선 개수)/ outdegree(나가는 간선 개수)가 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;경로(path): 끝과 끝이 서로 연결된 간선들을 순서대로 나열할 것
    &lt;ul&gt;
      &lt;li&gt;단순 경로: 경로 중 한 점을 최대 한번만 지나도록 한 경로 / 특정 언급을 안할 경우 대부분 경로 찾기시 이것을 의미한다.&lt;/li&gt;
      &lt;li&gt;Cycle: 방향 그래프에서 많이 사용되는 개념/ 간선을 따라가다 시작한 정점으로 돌아오는 경로를 의미 (1-&amp;gt;2-&amp;gt;3-&amp;gt;1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프 표현 방법
    &lt;ul&gt;
      &lt;li&gt;간선의 정보 저장 방식에 따라 나뉨&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접리스트 표현: vector&amp;lt;vector&lt;int&gt;&amp;gt; list;&lt;/int&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V+E)    
간선의 수 적은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접행렬 표현: vector&amp;lt;vector&lt;bool&gt;&amp;gt; matrix; 또는 int matrix[][];&lt;/bool&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V*V)  
두 정점간 연결 유무를 바로 알수 있다.  
간선의 수가 많은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_declare.png&quot; alt=&quot;정보 저장 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="DFS" /><category term="graph" /><summary type="html">DFS, BFS에서 사용되는 그래프 자료구조에 대한 설명</summary></entry></feed>