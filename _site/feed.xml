<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-17T01:08:57+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Portfolio</title><subtitle>공부, 프로젝트 등을 기록하기 위한 저장 공간.</subtitle><author><name>육상은</name></author><entry><title type="html">Bfs Problem1</title><link href="http://localhost:4000/bfs-problem1/" rel="alternate" type="text/html" title="Bfs Problem1" /><published>2020-02-16T00:00:00+09:00</published><updated>2020-02-16T00:00:00+09:00</updated><id>http://localhost:4000/bfs-problem1</id><content type="html" xml:base="http://localhost:4000/bfs-problem1/"></content><author><name>육상은</name></author><summary type="html"></summary></entry><entry><title type="html">DP(Dynamic Programming)</title><link href="http://localhost:4000/algorithm/dp/" rel="alternate" type="text/html" title=" DP(Dynamic Programming)" /><published>2020-02-16T00:00:00+09:00</published><updated>2020-02-17T00:15:00+09:00</updated><id>http://localhost:4000/algorithm/dp</id><content type="html" xml:base="http://localhost:4000/algorithm/dp/">&lt;h2 id=&quot;dpdynamic-programming---동적-계획법&quot;&gt;&lt;strong&gt;DP(Dynamic Programming) - 동적 계획법&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;큰 문제를 작은 문제로 나눠서 푸는&lt;/strong&gt; 기법을 의미하며, 참고로 알고리즘 이름과 의미는 별개이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;작은 문제들에 대해 계산한 값을 여러 번 사용할 수 있기 때문에 &lt;strong&gt;메모이제이션&lt;/strong&gt;이 필요&lt;/li&gt;
      &lt;li&gt;점화식을 잘 세우는 것이 중요(식과 초기 값)&lt;/li&gt;
      &lt;li&gt;종류: 1차 배열 dp, 2차 배열 dp …&lt;/li&gt;
      &lt;li&gt;(분할 정복과 차이: 분할 정복은 문제를 분할했을 때 겹치는 문제가 발생 안함)&lt;/li&gt;
      &lt;li&gt;ex) 이항계수(nCr)의 계산, 피보나치 수열(Fn = Fn-1 + Fn-2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시간 절약을 위한 Memoization
    &lt;ul&gt;
      &lt;li&gt;ex) 이항계수의 계산&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;점화식: Bino(a,b) = Bino(a-1, b) + Bino(a-1, b-1)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;bino(4,2)를 호출 시 bino()함수가 재귀적으로 호출&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bino(4,2) = bino(3,1) + bino(3,2)
bino(3,1) = bino(2,0) + bino(2,1)
bino(2,1) = bino(1,0) + bino(1,1)
bino(3,2) = bino(2,1) + bino(2,2)
bino(2,1) = bino(1,0) + bino(1,1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;위에 호출된 bino()함수를 볼 때 bino(2,1)이 중복적으로 호출된다. (bino(2,1)에 의해 그 밑 bino(1,0), bino(1,1)도 중복 호출된다.)&lt;/li&gt;
      &lt;li&gt;이 경우 중복된 계산 수행을 방지하여 시간 단축을 가능하게 하는 기법이 memoization이다.&lt;/li&gt;
      &lt;li&gt;계산된 결과를 배열에 저장한 뒤, 다음계산에서 필요한 경우 저장된 값을 불러와 불필요한 함수 호출 및 계산을 하지 않게 한다.&lt;/li&gt;
      &lt;li&gt;(시간 복잡도가 훨씬 줄어들게 됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DP 방식
    &lt;ul&gt;
      &lt;li&gt;Top-Down&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;일반 재귀와 같은 방식으로 위에서 아래로 내려오는 방식이며, memoization을 사용하기 위해 배열에 계산된 값들을 저장한다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;16916750번 피보나치 수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
using namespace std;
	  
int dp[45];	//-1로 초기화 (아직 값이 저장안됨을 의미)
int fbo(int n) {
     if ( dp[n] != -1 ) return dp[n];	//계산된 값 존재하는 경우
     dp[n] = fbo(n-1)+fbo(n-2);	//피보나치 수열 점화식 fbo(n) = fbo(n-1)+fbo(n-2);
     return dp[n];
}
int main() {
     int n;
     scanf(&quot;%d&quot;, &amp;amp;n);
     dp[0] = 0;	//초기값 설정 fbo(0), fbo(1)
     dp[1] = 1;
     for(int i=2; i&amp;lt;=n; i++) dp[i] = -1;
	  
     printf(&quot;%d&quot;, fbo(n));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Bottom-Up
    &lt;ul&gt;
      &lt;li&gt;for문을 이용해서 처음 값부터 다음 값을 계산해 나가는 방식&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;16916750번 피보나치 수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
using namespace std;
	  
int dp[45];  
	  
int main() {
     int n;
     scanf( &quot;%d&quot;, &amp;amp;n );
     dp[0] = 0;	//초기값 설정 fbo(0), fbo(1)
     dp[1] = 1;
     for(int i=2; i&amp;lt;=n; i++) 
          dp[i] = dp[i-1] + dp[i-2];
	  
     printf( &quot;%d&quot;, dp[n] );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;차이
    &lt;ul&gt;
      &lt;li&gt;Top-down 방식에 메모이제이션을 했다는 가정하에 시간 복잡도는 같다.&lt;/li&gt;
      &lt;li&gt;하지만 재귀적으로 함수를 호출하는 과정 때문에 실제 걸리는 시간은 top-down DP가 더 길다고 알려져 있다.&lt;/li&gt;
      &lt;li&gt;Top-down DP의 장점: 점화식 그대로 호출이 되기 때문에 형식/순서에 얽매이지 않고 가독성이 좋다.&lt;/li&gt;
      &lt;li&gt;Bottum-Up DP의 장점: 함수를 호출하지 않으므로 시간/메모리 소량 절약&lt;/li&gt;
      &lt;li&gt;문제에 따라 둘 중 편한 방법을 사용하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>육상은</name></author><category term="DP" /><summary type="html">큰 문제를 작은 문제들로 나눠서 푸는 기법</summary></entry><entry><title type="html">BFS Algorithm</title><link href="http://localhost:4000/algorithm/bfs/" rel="alternate" type="text/html" title="BFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/bfs</id><content type="html" xml:base="http://localhost:4000/algorithm/bfs/">&lt;h2 id=&quot;bfsbreadth-first-search---너비-우선-탐색&quot;&gt;&lt;strong&gt;BFS(Breadth First Search) - 너비 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BFS
    &lt;ul&gt;
      &lt;li&gt;시작점에 가까운 정점부터 순서대로 방문(모든 곳을 공평하게 조금씩 본다.)&lt;/li&gt;
      &lt;li&gt;즉 시작점을 0단계, 그 다음부터 1, 2, ..k..단계라고 할 때, &lt;strong&gt;k단계에 방문하는 정점들을 시작점으로부터 최단거리가 k라고 한다.&lt;/strong&gt;(A에서 B로 이동하는 데 필요한 최소 개수의 간선)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;최단경로 문제를 풀 때 유용하다.&lt;/strong&gt;  (깊이를 알 수 있으므로)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;각 정점들을 방문할 때마다 모든 인접 정점들을 검사&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: queue를 이용하여 방문할 list를 저장한다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서    
ex) 1 - 2 - 3 - 5 - 6 - 9  
        ㄴ  4   ㄴ  7 - 8  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;9-&amp;gt;8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 16881461번)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs(int start) {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[start] = true;	//방문되는 노드들 표시
        qu.push(start);
        while ( !qu.empty()) {
             int here = qu.front();
             printf(&quot;%d &quot;, here);	//방문 순서대로 출력
             qu.pop();
             //간선으로 연결된 다른 정점들 탐색
             for (int next : vt[start]) {
                  if (!visited[next]) {	//방문되지 않은 노드 경우 탐색
                       visited[next] = true;
                       qu.push(next);
                  }
             }
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //bfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        bfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 17652404번 - 촌수계산(최단거리 이용문제))&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;queue&amp;gt;
   using namespace std;
	
   int n, p1, p2;	//정점의 개수, 구하고자 하는 두 사람  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void bfs() {
        queue&amp;lt;int&amp;gt; qu;	//방문할 노드 대기 list
        visited[p1-1] = true;	//방문되는 노드들 표시
        qu.push(p1-1);
        int level = 1;	//p1으로부터의 거리 체크
        while ( !qu.empty()) {	//이 부분에서는 항상 q에 있는 정점들은 같은 레벨
             int size = qu.size();	//같은 레벨에 속한 정점의 개수를 반환
             while(size--) {	//같은 레벨 정점들에 대해서 연결된 다른 노드들 검사
                  int here = qu.front();
                  qu.pop();
                  //간선으로 연결된 다른 정점들 탐색
                  for (int i = 0; i &amp;lt; vt[here].size(); i++) {
                       if (visited[vt[here][i]]) continue;
                       if (vt[here][i] == p2 - 1) return level;
                       visited[vt[here][i]] = true;
                       qu.push(vt[here][i]);
                  }
             }
             level++;
        }
        return -1;
   }
 
   int main() {
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;p1, &amp;amp;p2);
        visited.resize(n);	//노드 개수에 맞게 크기 조정
        vt.resize(n);
        scanf(&quot;%d&quot;, &amp;amp;n);
        while (n--) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a-1].push_back(b-1);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b-1].push_back(a-1);
        }
        printf(&quot;%d&quot;, bfs() );
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 너비 우선 탐색 알고리즘</summary></entry><entry><title type="html">DFS Algorithm</title><link href="http://localhost:4000/algorithm/dfs/" rel="alternate" type="text/html" title="DFS Algorithm" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-15T00:15:00+09:00</updated><id>http://localhost:4000/algorithm/dfs</id><content type="html" xml:base="http://localhost:4000/algorithm/dfs/">&lt;h2 id=&quot;dfsdepth-first-search---깊이-우선-탐색&quot;&gt;&lt;strong&gt;DFS(Depth First Search) - 깊이 우선 탐색&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;탐색
    &lt;ul&gt;
      &lt;li&gt;모든 정점들을 특정 순서에 따라 방문하는 알고리즘&lt;/li&gt;
      &lt;li&gt;그래프의 구조를 알 수 있다. (bfs, dfs 알고리즘을 이용)&lt;/li&gt;
      &lt;li&gt;DFS는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DFS
    &lt;ul&gt;
      &lt;li&gt;현재 정점에서 더 이상 다른 정점으로 이동할 수 없는 상태에 도달할 때까지 탐색 후 이전 정점으로 돌아가 연결된 다른 정점에 대해 같은 방식으로 반복한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;더 이상 다른 정점으로 이동할 수 없을 때 이전 정점으로 돌아가므로 구현시 지금 까지 거쳐온 정점들을 모두 저장해둬야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방법: Stack을 이용한 push/pop  , 재귀함수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;** 순서  
ex) 1 - 2 - 3 - 5 - 6  
        ㄴ  4   ㄴ  7  
경로: 1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;5(back한 것)-&amp;gt;7-&amp;gt;5(back)-&amp;gt;3(back)-&amp;gt;2(back)-&amp;gt;4-&amp;gt;2(back)-&amp;gt;1(back)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;dfs는 대개 그래프 전체 구조를 파악하기 위해 사용 ex)연결된 부분집합의 개수 크기
        &lt;ul&gt;
          &lt;li&gt;부분집합 = component = 요소: 하나의 graph에는 1개 이상의 컴포넌트 존재&lt;/li&gt;
          &lt;li&gt;컴포넌트 하나 안에 속한 정점은 서로 모두 이어져 있으며, 다른 컴포넌트 끼리는 이어져 있지 않다.&lt;/li&gt;
          &lt;li&gt;또한 컴포넌트는 항상 가능한 최대의 크기&lt;/li&gt;
          &lt;li&gt;connected graph: 그래프의 컴포넌트가 단 하나인 경우로 모든 정점이 연결되어 있다.&lt;/li&gt;
          &lt;li&gt;찾는 방법: 노드 i에서 시작하는 dfs(i)탐색시 탐색 종료 후 i를 포함한 방문된 모든 노드들은 모두 하나의 컴포넌트에 속한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시간복잡도
        &lt;ul&gt;
          &lt;li&gt;인접리스트: O(V+E)&lt;/li&gt;
          &lt;li&gt;인접행렬: O(V*V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 (백준 16881461번)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include&amp;lt;stdio.h&amp;gt;
   #include&amp;lt;vector&amp;gt;
   #include&amp;lt;algorithm&amp;gt;
   using namespace std;
	
   int n, m;	//정점, 간선의 개수  
   vector&amp;lt;bool&amp;gt; visited;	//정점 방문유무 확인
   vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vt;	//그래프 정보(인접리스트)
	  
   void dfs(int start) {
        visited[start] = true;	//방문되는 노드들 표시
        printf(&quot;%d &quot;, start);	//방문 순서대로 출력
        //간선으로 연결된 다른 정점들 탐색
        for (int next : vt[start]) {
             if (!visited[next]) dfs(next);	//방문되지 않은 노드 경우 탐색
        }
   }
 
   int main() {
        int v;		//탐색 시작 정점 번호
        scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;v);
	  
        visited.resize(n+1);	//노드 개수에 맞게 크기 조정
        vt.resize(n+1);
        for ( int i = 0; i &amp;lt; m; i++) {
             int a, b;
             scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
             vt[a].push_back(b);	//무방향 그래프 경우 서로 이동 가능하므로 양쪽에 넣어준다.
             vt[b].push_back(a);
        }
        //정점 번호 작은 것부터 방문해야 하므로 정렬
        for(int i = 1; i &amp;lt;= n; i++) sort(vt[i].begin(), vt[i].end());
        //dfs
        fill(visited.begin(), visited.end(), false);	//모든 노드 방문 안된 상태로 초기화
        dfs(v);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>육상은</name></author><category term="DFS" /><category term="graph" /><summary type="html">그래프 자료구조를 이용한 깊이 우선 탐색 알고리즘</summary></entry><entry><title type="html">Graph</title><link href="http://localhost:4000/data%20structure/graph/" rel="alternate" type="text/html" title="Graph" /><published>2020-02-13T00:00:00+09:00</published><updated>2020-02-13T11:14:00+09:00</updated><id>http://localhost:4000/data%20structure/graph</id><content type="html" xml:base="http://localhost:4000/data%20structure/graph/">&lt;h2 id=&quot;1-그래프-설명&quot;&gt;&lt;strong&gt;1. 그래프 설명&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현실세계에서는 도로망, 지인관계, 링크관계 등의 연결고리들을 표현할 수 있다.&lt;/li&gt;
  &lt;li&gt;정의: 정점(vertex)과 간선(edge)의 집합  G(V,E)&lt;/li&gt;
  &lt;li&gt;정점: 노드(node)라고도 부른다.&lt;/li&gt;
  &lt;li&gt;간선: 유형에 따라 나뉜다.
    &lt;ol&gt;
      &lt;li&gt;두 정점을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;자기자신을 이어주는 간선&lt;/li&gt;
      &lt;li&gt;방향이 있는 간선/ 없는 간선 - 방향이 있는 간선의 경우 사이클 발생 가능&lt;/li&gt;
      &lt;li&gt;가중치가 있는/ 없는 간선&lt;/li&gt;
      &lt;li&gt;DAG: 여러 유형의 간선을 혼합한 것들 중 방향그래프이면서 사이클이 존재하는 그래프를 지칭&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_case.png&quot; alt=&quot;간선 유형에 따른 그림&quot; title=&quot;간선 유형에 따른 그림&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차수(degree): 한 정점에 이어진(인접한) 간선의 개수
    &lt;ul&gt;
      &lt;li&gt;인접하다(adjacent): 두 정점이 간선으로 이어져 있을 때를 의미&lt;/li&gt;
      &lt;li&gt;방향 그래프에서는 indegree(들어오는 간선 개수)/ outdegree(나가는 간선 개수)가 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;경로(path): 끝과 끝이 서로 연결된 간선들을 순서대로 나열할 것
    &lt;ul&gt;
      &lt;li&gt;단순 경로: 경로 중 한 점을 최대 한번만 지나도록 한 경로 / 특정 언급을 안할 경우 대부분 경로 찾기시 이것을 의미한다.&lt;/li&gt;
      &lt;li&gt;Cycle: 방향 그래프에서 많이 사용되는 개념/ 간선을 따라가다 시작한 정점으로 돌아오는 경로를 의미 (1-&amp;gt;2-&amp;gt;3-&amp;gt;1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프 표현 방법
    &lt;ul&gt;
      &lt;li&gt;간선의 정보 저장 방식에 따라 나뉨&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접리스트 표현: vector&amp;lt;vector&lt;int&gt;&amp;gt; list;&lt;/int&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V+E)    
간선의 수 적은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인접행렬 표현: vector&amp;lt;vector&lt;bool&gt;&amp;gt; matrix; 또는 int matrix[][];&lt;/bool&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;공간복잡도 O(V*V)  
두 정점간 연결 유무를 바로 알수 있다.  
간선의 수가 많은 그래프에서 유리하다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuksangeun.github.io/assets/images/graph_declare.png&quot; alt=&quot;정보 저장 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>육상은</name></author><category term="BFS" /><category term="DFS" /><category term="graph" /><summary type="html">DFS, BFS에서 사용되는 그래프 자료구조에 대한 설명</summary></entry></feed>